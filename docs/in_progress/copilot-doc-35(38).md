# Copilot ë¬¸ì„œ #38: ì™¸ë¶€ ì—ë„ˆì§€ ê³µê¸‰ì ì—°ë™ ì‹œìŠ¤í…œ

## ëª©í‘œ
ë³¸ì‚¬ ì—ë„ˆì§€ í’€ì´ ë¶€ì¡±í•  ë•Œ ì™¸ë¶€ ì—ë„ˆì§€ ê³µê¸‰ìë¡œë¶€í„° ì‹¤ì‹œê°„ìœ¼ë¡œ ì—ë„ˆì§€ë¥¼ êµ¬ë§¤/ëŒ€ì—¬í•˜ì—¬ ì„œë¹„ìŠ¤ ì¤‘ë‹¨ì„ ë°©ì§€í•©ë‹ˆë‹¤. ìë™/ìˆ˜ë™ êµ¬ë§¤ ì˜µì…˜ì„ ì œê³µí•˜ê³ , êµ¬ë§¤í•œ ì—ë„ˆì§€ì— ë§ˆì§„ì„ ì¶”ê°€í•˜ì—¬ íŒŒíŠ¸ë„ˆì‚¬ì—ê²Œ ì œê³µí•©ë‹ˆë‹¤.

## ì „ì œ ì¡°ê±´
- Copilot ë¬¸ì„œ #36(ì—ë„ˆì§€ ë Œíƒˆ ì„œë¹„ìŠ¤)ì´ ì™„ë£Œë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤
- ë³¸ì‚¬ ì—ë„ˆì§€ í’€ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œì´ êµ¬ì¶•ë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤
- TRON ë„¤íŠ¸ì›Œí¬ ì—°ë™ì´ ì™„ë£Œë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤
- ì¶©ë¶„í•œ TRX/USDT ìœ ë™ì„±ì´ í™•ë³´ë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤

## ğŸ¯ ì™¸ë¶€ ì—ë„ˆì§€ ê³µê¸‰ì ì—°ë™ êµ¬ì¡°

### ğŸ“Š ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜
```
ì™¸ë¶€ ì—ë„ˆì§€ ê³µê¸‰ì ì—°ë™
â”œâ”€â”€ ğŸª ê³µê¸‰ì ê´€ë¦¬
â”‚   â”œâ”€â”€ JustLend Energy Market
â”‚   â”œâ”€â”€ TronNRG
â”‚   â”œâ”€â”€ TRONSCAN Energy
â”‚   â””â”€â”€ P2P Energy Trading
â”œâ”€â”€ ğŸ’± ê°€ê²© ëª¨ë‹ˆí„°ë§
â”‚   â”œâ”€â”€ ì‹¤ì‹œê°„ ì‹œì„¸ ì¡°íšŒ
â”‚   â”œâ”€â”€ ê°€ê²© ë¹„êµ ì—”ì§„
â”‚   â”œâ”€â”€ ìµœì  ê³µê¸‰ì ì„ íƒ
â”‚   â””â”€â”€ ê°€ê²© íˆìŠ¤í† ë¦¬
â”œâ”€â”€ ğŸ¤– ìë™ êµ¬ë§¤ ì‹œìŠ¤í…œ
â”‚   â”œâ”€â”€ ì„ê³„ê°’ ëª¨ë‹ˆí„°ë§
â”‚   â”œâ”€â”€ êµ¬ë§¤ ê·œì¹™ ì—”ì§„
â”‚   â”œâ”€â”€ ë¦¬ìŠ¤í¬ ê´€ë¦¬
â”‚   â””â”€â”€ êµ¬ë§¤ ì‹¤í–‰
â”œâ”€â”€ ğŸ‘¤ ìˆ˜ë™ êµ¬ë§¤ ì¸í„°í˜ì´ìŠ¤
â”‚   â”œâ”€â”€ ì‹œì¥ í˜„í™© ëŒ€ì‹œë³´ë“œ
â”‚   â”œâ”€â”€ êµ¬ë§¤ ìŠ¹ì¸ í”„ë¡œì„¸ìŠ¤
â”‚   â”œâ”€â”€ ê¸´ê¸‰ êµ¬ë§¤ ì˜µì…˜
â”‚   â””â”€â”€ êµ¬ë§¤ ì´ë ¥
â””â”€â”€ ğŸ’° ë§ˆì§„ ê´€ë¦¬
    â”œâ”€â”€ ë™ì  ë§ˆì§„ ì„¤ì •
    â”œâ”€â”€ ê³µê¸‰ìë³„ ë§ˆì§„
    â”œâ”€â”€ ê¸´ê¸‰ë„ë³„ ë§ˆì§„
    â””â”€â”€ ìˆ˜ìµì„± ë¶„ì„
```

## ğŸ› ï¸ êµ¬í˜„ ë‹¨ê³„

### Phase 1: ì™¸ë¶€ ê³µê¸‰ì í†µí•© ëª¨ë¸ (2ì¼)

#### 1.1 ë°ì´í„°ë² ì´ìŠ¤ ëª¨ë¸
```python
# app/models/external_energy.py
from sqlalchemy import Column, Integer, String, Numeric, DateTime, Boolean, Enum, JSON, ForeignKey
from sqlalchemy.orm import relationship
from decimal import Decimal
import enum

class EnergyProviderType(enum.Enum):
    """ì—ë„ˆì§€ ê³µê¸‰ì ìœ í˜•"""
    JUSTLEND = "justlend"          # JustLend Energy Market
    TRONNRG = "tronnrg"            # TronNRG
    TRONSCAN = "tronscan"          # TRONSCAN Energy
    P2P = "p2p"                    # P2P Trading Platform
    SPOT = "spot"                  # Spot Market

class PurchaseStatus(enum.Enum):
    """êµ¬ë§¤ ìƒíƒœ"""
    PENDING = "pending"            # ëŒ€ê¸°ì¤‘
    APPROVED = "approved"          # ìŠ¹ì¸ë¨
    EXECUTING = "executing"        # ì‹¤í–‰ì¤‘
    COMPLETED = "completed"        # ì™„ë£Œ
    FAILED = "failed"              # ì‹¤íŒ¨
    CANCELLED = "cancelled"        # ì·¨ì†Œë¨

class ExternalEnergyProvider(Base):
    """ì™¸ë¶€ ì—ë„ˆì§€ ê³µê¸‰ì"""
    __tablename__ = "external_energy_providers"
    
    id = Column(Integer, primary_key=True)
    provider_type = Column(Enum(EnergyProviderType), unique=True, nullable=False)
    name = Column(String(100), nullable=False)
    api_endpoint = Column(String(500))
    api_key = Column(String(255))
    api_secret = Column(String(255))
    
    # ê³µê¸‰ì ì„¤ì •
    is_active = Column(Boolean, default=True)
    priority = Column(Integer, default=1)  # ë‚®ì„ìˆ˜ë¡ ìš°ì„ ìˆœìœ„ ë†’ìŒ
    max_daily_purchase = Column(Numeric(20, 6))  # ì¼ì¼ ìµœëŒ€ êµ¬ë§¤ëŸ‰
    min_purchase_amount = Column(Integer)  # ìµœì†Œ êµ¬ë§¤ ì—ë„ˆì§€
    max_purchase_amount = Column(Integer)  # ìµœëŒ€ êµ¬ë§¤ ì—ë„ˆì§€
    
    # ê°€ê²© ì •ë³´
    last_price = Column(Numeric(20, 10))  # ë§ˆì§€ë§‰ ì¡°íšŒ ê°€ê²©
    price_updated_at = Column(DateTime)
    average_price_24h = Column(Numeric(20, 10))
    
    # ì‹ ë¢°ë„ ë° ì„±ëŠ¥
    success_rate = Column(Numeric(5, 2), default=Decimal("100"))
    average_response_time = Column(Integer)  # milliseconds
    total_purchases = Column(Integer, default=0)
    total_energy_purchased = Column(Numeric(20, 0), default=0)
    
    # ë©”íƒ€ë°ì´í„°
    metadata = Column(JSON)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # ê´€ê³„
    price_history = relationship("EnergyPriceHistory", back_populates="provider")
    purchases = relationship("ExternalEnergyPurchase", back_populates="provider")

class EnergyPriceHistory(Base):
    """ì—ë„ˆì§€ ê°€ê²© íˆìŠ¤í† ë¦¬"""
    __tablename__ = "energy_price_history"
    
    id = Column(Integer, primary_key=True)
    provider_id = Column(Integer, ForeignKey("external_energy_providers.id"))
    
    price_per_energy = Column(Numeric(20, 10), nullable=False)
    available_amount = Column(Integer)  # êµ¬ë§¤ ê°€ëŠ¥ëŸ‰
    min_order = Column(Integer)
    max_order = Column(Integer)
    
    recorded_at = Column(DateTime, default=datetime.utcnow)
    
    # ê´€ê³„
    provider = relationship("ExternalEnergyProvider", back_populates="price_history")

class ExternalEnergyPurchase(Base):
    """ì™¸ë¶€ ì—ë„ˆì§€ êµ¬ë§¤ ê¸°ë¡"""
    __tablename__ = "external_energy_purchases"
    
    id = Column(Integer, primary_key=True)
    provider_id = Column(Integer, ForeignKey("external_energy_providers.id"))
    
    # êµ¬ë§¤ ì •ë³´
    energy_amount = Column(Integer, nullable=False)
    price_per_energy = Column(Numeric(20, 10), nullable=False)
    total_cost = Column(Numeric(20, 6), nullable=False)
    payment_currency = Column(String(10))  # "TRX", "USDT"
    
    # ìƒíƒœ ê´€ë¦¬
    status = Column(Enum(PurchaseStatus), default=PurchaseStatus.PENDING)
    purchase_type = Column(String(20))  # "auto", "manual", "emergency"
    
    # ìŠ¹ì¸ ì •ë³´
    requested_by = Column(Integer, ForeignKey("users.id"))
    approved_by = Column(Integer, ForeignKey("users.id"))
    approved_at = Column(DateTime)
    
    # ì‹¤í–‰ ì •ë³´
    transaction_hash = Column(String(64))
    energy_received_at = Column(DateTime)
    actual_energy_received = Column(Integer)
    
    # ë§ˆì§„ ë° ì¬íŒë§¤
    margin_rate = Column(Numeric(5, 4), default=Decimal("0.2"))  # 20% ê¸°ë³¸ ë§ˆì§„
    resale_price = Column(Numeric(20, 10))
    
    # ìë™ êµ¬ë§¤ íŠ¸ë¦¬ê±°
    trigger_reason = Column(String(100))  # "low_energy", "scheduled", "emergency"
    energy_level_at_purchase = Column(Integer)  # êµ¬ë§¤ ì‹œì  ì—ë„ˆì§€ ì”ëŸ‰
    
    created_at = Column(DateTime, default=datetime.utcnow)
    completed_at = Column(DateTime)
    
    # ê´€ê³„
    provider = relationship("ExternalEnergyProvider", back_populates="purchases")
    requested_user = relationship("User", foreign_keys=[requested_by])
    approved_user = relationship("User", foreign_keys=[approved_by])

class EnergyPurchaseRule(Base):
    """ì—ë„ˆì§€ ìë™ êµ¬ë§¤ ê·œì¹™"""
    __tablename__ = "energy_purchase_rules"
    
    id = Column(Integer, primary_key=True)
    name = Column(String(100), nullable=False)
    is_active = Column(Boolean, default=True)
    priority = Column(Integer, default=1)
    
    # íŠ¸ë¦¬ê±° ì¡°ê±´
    trigger_type = Column(String(50))  # "threshold", "schedule", "prediction"
    energy_threshold = Column(Integer)  # ì—ë„ˆì§€ ì„ê³„ê°’
    threshold_percentage = Column(Numeric(5, 2))  # ì„ê³„ ë¹„ìœ¨
    schedule_cron = Column(String(100))  # ìŠ¤ì¼€ì¤„ (cron í‘œí˜„ì‹)
    
    # êµ¬ë§¤ ì„¤ì •
    purchase_amount = Column(Integer)  # êµ¬ë§¤í•  ì—ë„ˆì§€ëŸ‰
    purchase_percentage = Column(Numeric(5, 2))  # ì „ì²´ ìš©ëŸ‰ì˜ %
    max_price = Column(Numeric(20, 10))  # ìµœëŒ€ í—ˆìš© ê°€ê²©
    preferred_providers = Column(JSON)  # ì„ í˜¸ ê³µê¸‰ì ëª©ë¡
    
    # ë§ˆì§„ ì„¤ì •
    margin_type = Column(String(20))  # "fixed", "dynamic"
    base_margin = Column(Numeric(5, 4), default=Decimal("0.2"))
    emergency_margin = Column(Numeric(5, 4), default=Decimal("0.5"))
    
    # ì‹¤í–‰ ì œí•œ
    max_daily_executions = Column(Integer, default=10)
    cooldown_minutes = Column(Integer, default=30)
    last_executed_at = Column(DateTime)
    daily_execution_count = Column(Integer, default=0)
    
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
```

### Phase 2: ì™¸ë¶€ ê³µê¸‰ì ì—°ë™ ì„œë¹„ìŠ¤ (3ì¼)

#### 2.1 ê°€ê²© ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤
```python
# app/services/external_energy/price_monitor.py
from typing import List, Dict, Optional
from decimal import Decimal
import asyncio
import aiohttp
from datetime import datetime, timedelta

class EnergyPriceMonitor:
    def __init__(self, db):
        self.db = db
        self.providers = self._load_active_providers()
        
    async def fetch_current_prices(self) -> Dict:
        """ëª¨ë“  ê³µê¸‰ìì˜ í˜„ì¬ ê°€ê²© ì¡°íšŒ"""
        tasks = []
        for provider in self.providers:
            task = self._fetch_provider_price(provider)
            tasks.append(task)
            
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        prices = {}
        for provider, result in zip(self.providers, results):
            if not isinstance(result, Exception):
                prices[provider.provider_type.value] = result
                
        return prices
        
    async def _fetch_provider_price(self, provider: ExternalEnergyProvider) -> Dict:
        """ê°œë³„ ê³µê¸‰ì ê°€ê²© ì¡°íšŒ"""
        if provider.provider_type == EnergyProviderType.JUSTLEND:
            return await self._fetch_justlend_price(provider)
        elif provider.provider_type == EnergyProviderType.TRONNRG:
            return await self._fetch_tronnrg_price(provider)
        elif provider.provider_type == EnergyProviderType.TRONSCAN:
            return await self._fetch_tronscan_price(provider)
        elif provider.provider_type == EnergyProviderType.P2P:
            return await self._fetch_p2p_price(provider)
            
    async def _fetch_justlend_price(self, provider) -> Dict:
        """JustLend Energy Market ê°€ê²© ì¡°íšŒ"""
        async with aiohttp.ClientSession() as session:
            headers = {"API-Key": provider.api_key}
            url = f"{provider.api_endpoint}/energy/price"
            
            async with session.get(url, headers=headers) as response:
                data = await response.json()
                
                return {
                    "provider": "JustLend",
                    "price": Decimal(str(data["price"])),
                    "available": data["available_energy"],
                    "min_order": data["min_order_size"],
                    "max_order": data["max_order_size"],
                    "estimated_time": data["fulfillment_time"],
                    "timestamp": datetime.utcnow()
                }
                
    async def _fetch_tronnrg_price(self, provider) -> Dict:
        """TronNRG ê°€ê²© ì¡°íšŒ"""
        async with aiohttp.ClientSession() as session:
            url = f"{provider.api_endpoint}/api/v1/energy/market"
            
            async with session.get(url) as response:
                data = await response.json()
                
                # TronNRGëŠ” ì—¬ëŸ¬ íŒë§¤ìê°€ ìˆì„ ìˆ˜ ìˆìŒ
                best_offer = min(data["offers"], key=lambda x: x["price"])
                
                return {
                    "provider": "TronNRG",
                    "price": Decimal(str(best_offer["price"])),
                    "available": best_offer["amount"],
                    "min_order": 100000,  # 10ë§Œ ì—ë„ˆì§€
                    "max_order": best_offer["amount"],
                    "seller_rating": best_offer["seller"]["rating"],
                    "timestamp": datetime.utcnow()
                }
                
    async def find_best_price(self, energy_amount: int) -> Optional[Dict]:
        """í•„ìš”í•œ ì—ë„ˆì§€ëŸ‰ì— ëŒ€í•œ ìµœì  ê°€ê²© ì°¾ê¸°"""
        prices = await self.fetch_current_prices()
        
        valid_offers = []
        for provider_type, price_info in prices.items():
            if (price_info["available"] >= energy_amount and
                price_info["min_order"] <= energy_amount <= price_info["max_order"]):
                valid_offers.append({
                    "provider_type": provider_type,
                    **price_info
                })
                
        if not valid_offers:
            return None
            
        # ê°€ê²©ìˆœ ì •ë ¬
        return min(valid_offers, key=lambda x: x["price"])
        
    async def record_price_history(self):
        """ê°€ê²© íˆìŠ¤í† ë¦¬ ê¸°ë¡"""
        prices = await self.fetch_current_prices()
        
        for provider in self.providers:
            if provider.provider_type.value in prices:
                price_info = prices[provider.provider_type.value]
                
                history = EnergyPriceHistory(
                    provider_id=provider.id,
                    price_per_energy=price_info["price"],
                    available_amount=price_info.get("available"),
                    min_order=price_info.get("min_order"),
                    max_order=price_info.get("max_order")
                )
                
                self.db.add(history)
                
                # ê³µê¸‰ì ì •ë³´ ì—…ë°ì´íŠ¸
                provider.last_price = price_info["price"]
                provider.price_updated_at = datetime.utcnow()
                
        self.db.commit()
```

#### 2.2 ìë™ êµ¬ë§¤ ì—”ì§„
```python
# app/services/external_energy/auto_purchase_engine.py
from typing import Optional, Dict, List
import logging

logger = logging.getLogger(__name__)

class AutoPurchaseEngine:
    def __init__(self, db, price_monitor: EnergyPriceMonitor):
        self.db = db
        self.price_monitor = price_monitor
        
    async def check_and_execute_rules(self) -> List[ExternalEnergyPurchase]:
        """ìë™ êµ¬ë§¤ ê·œì¹™ í™•ì¸ ë° ì‹¤í–‰"""
        executed_purchases = []
        
        # í™œì„± ê·œì¹™ ì¡°íšŒ
        active_rules = self.db.query(EnergyPurchaseRule).filter(
            EnergyPurchaseRule.is_active == True
        ).order_by(EnergyPurchaseRule.priority).all()
        
        current_energy = await self._get_current_energy_level()
        total_capacity = await self._get_total_capacity()
        
        for rule in active_rules:
            if self._should_execute_rule(rule, current_energy, total_capacity):
                purchase = await self._execute_purchase(rule, current_energy)
                if purchase:
                    executed_purchases.append(purchase)
                    
        return executed_purchases
        
    def _should_execute_rule(
        self, 
        rule: EnergyPurchaseRule, 
        current_energy: int,
        total_capacity: int
    ) -> bool:
        """ê·œì¹™ ì‹¤í–‰ ì—¬ë¶€ íŒë‹¨"""
        # ì¿¨ë‹¤ìš´ ì²´í¬
        if rule.last_executed_at:
            cooldown_end = rule.last_executed_at + timedelta(minutes=rule.cooldown_minutes)
            if datetime.utcnow() < cooldown_end:
                return False
                
        # ì¼ì¼ ì‹¤í–‰ ì œí•œ ì²´í¬
        if rule.daily_execution_count >= rule.max_daily_executions:
            return False
            
        # íŠ¸ë¦¬ê±° ì¡°ê±´ ì²´í¬
        if rule.trigger_type == "threshold":
            if rule.energy_threshold and current_energy < rule.energy_threshold:
                return True
            if rule.threshold_percentage:
                current_percentage = (current_energy / total_capacity) * 100
                if current_percentage < rule.threshold_percentage:
                    return True
                    
        elif rule.trigger_type == "schedule":
            # ìŠ¤ì¼€ì¤„ ê¸°ë°˜ ì‹¤í–‰ (cron íŒŒì‹± í•„ìš”)
            pass
            
        elif rule.trigger_type == "prediction":
            # ML ê¸°ë°˜ ì˜ˆì¸¡ (í–¥í›„ êµ¬í˜„)
            pass
            
        return False
        
    async def _execute_purchase(
        self, 
        rule: EnergyPurchaseRule,
        current_energy: int
    ) -> Optional[ExternalEnergyPurchase]:
        """ìë™ êµ¬ë§¤ ì‹¤í–‰"""
        # êµ¬ë§¤ëŸ‰ ê³„ì‚°
        if rule.purchase_amount:
            amount = rule.purchase_amount
        elif rule.purchase_percentage:
            total_capacity = await self._get_total_capacity()
            amount = int(total_capacity * rule.purchase_percentage / 100)
        else:
            return None
            
        # ìµœì  ê°€ê²© ì°¾ê¸°
        best_offer = await self.price_monitor.find_best_price(amount)
        if not best_offer:
            logger.warning(f"No suitable offer found for {amount} energy")
            return None
            
        # ìµœëŒ€ ê°€ê²© ì²´í¬
        if rule.max_price and best_offer["price"] > rule.max_price:
            logger.warning(f"Price {best_offer['price']} exceeds max price {rule.max_price}")
            return None
            
        # ì„ í˜¸ ê³µê¸‰ì ì²´í¬
        if rule.preferred_providers:
            if best_offer["provider_type"] not in rule.preferred_providers:
                # ì„ í˜¸ ê³µê¸‰ì ì¤‘ì—ì„œ ë‹¤ì‹œ ì°¾ê¸°
                # ... êµ¬í˜„ í•„ìš”
                pass
                
        # ë§ˆì§„ ê³„ì‚°
        if current_energy < total_capacity * 0.1:  # 10% ë¯¸ë§Œ = ê¸´ê¸‰
            margin = rule.emergency_margin
            purchase_type = "emergency"
        else:
            margin = rule.base_margin
            purchase_type = "auto"
            
        # êµ¬ë§¤ ë ˆì½”ë“œ ìƒì„±
        provider = self.db.query(ExternalEnergyProvider).filter(
            ExternalEnergyProvider.provider_type == best_offer["provider_type"]
        ).first()
        
        purchase = ExternalEnergyPurchase(
            provider_id=provider.id,
            energy_amount=amount,
            price_per_energy=best_offer["price"],
            total_cost=best_offer["price"] * amount,
            payment_currency="TRX",
            status=PurchaseStatus.APPROVED,
            purchase_type=purchase_type,
            margin_rate=margin,
            resale_price=best_offer["price"] * (1 + margin),
            trigger_reason=f"rule:{rule.name}",
            energy_level_at_purchase=current_energy
        )
        
        self.db.add(purchase)
        
        # ê·œì¹™ ì—…ë°ì´íŠ¸
        rule.last_executed_at = datetime.utcnow()
        rule.daily_execution_count += 1
        
        self.db.commit()
        
        # ì‹¤ì œ êµ¬ë§¤ ì‹¤í–‰
        await self._process_purchase(purchase)
        
        return purchase
        
    async def _process_purchase(self, purchase: ExternalEnergyPurchase):
        """ì‹¤ì œ êµ¬ë§¤ í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰"""
        try:
            purchase.status = PurchaseStatus.EXECUTING
            self.db.commit()
            
            # ê³µê¸‰ìë³„ êµ¬ë§¤ API í˜¸ì¶œ
            provider = purchase.provider
            if provider.provider_type == EnergyProviderType.JUSTLEND:
                result = await self._purchase_from_justlend(purchase)
            elif provider.provider_type == EnergyProviderType.TRONNRG:
                result = await self._purchase_from_tronnrg(purchase)
            # ... ë‹¤ë¥¸ ê³µê¸‰ìë“¤
            
            if result["success"]:
                purchase.status = PurchaseStatus.COMPLETED
                purchase.transaction_hash = result["tx_hash"]
                purchase.actual_energy_received = result["energy_received"]
                purchase.completed_at = datetime.utcnow()
                
                # ê³µê¸‰ì í†µê³„ ì—…ë°ì´íŠ¸
                provider.total_purchases += 1
                provider.total_energy_purchased += result["energy_received"]
            else:
                purchase.status = PurchaseStatus.FAILED
                
        except Exception as e:
            logger.error(f"Purchase failed: {str(e)}")
            purchase.status = PurchaseStatus.FAILED
            
        self.db.commit()
```

#### 2.3 ìˆ˜ë™ êµ¬ë§¤ ì„œë¹„ìŠ¤
```python
# app/services/external_energy/manual_purchase_service.py
class ManualPurchaseService:
    def __init__(self, db, price_monitor: EnergyPriceMonitor):
        self.db = db
        self.price_monitor = price_monitor
        
    async def create_purchase_request(
        self,
        requested_by: int,
        energy_amount: int,
        max_price: Optional[Decimal] = None,
        preferred_provider: Optional[str] = None,
        urgency: str = "normal"  # "normal", "urgent", "emergency"
    ) -> ExternalEnergyPurchase:
        """ìˆ˜ë™ êµ¬ë§¤ ìš”ì²­ ìƒì„±"""
        # í˜„ì¬ ì‹œì¥ ê°€ê²© ì¡°íšŒ
        if preferred_provider:
            provider = self.db.query(ExternalEnergyProvider).filter(
                ExternalEnergyProvider.provider_type == preferred_provider
            ).first()
            prices = await self.price_monitor._fetch_provider_price(provider)
        else:
            best_offer = await self.price_monitor.find_best_price(energy_amount)
            if not best_offer:
                raise ValueError("No suitable offer found")
                
        # ë§ˆì§„ ì„¤ì •
        margin_rates = {
            "normal": Decimal("0.2"),    # 20%
            "urgent": Decimal("0.35"),   # 35%
            "emergency": Decimal("0.5")  # 50%
        }
        margin = margin_rates.get(urgency, Decimal("0.2"))
        
        # êµ¬ë§¤ ìš”ì²­ ìƒì„±
        purchase = ExternalEnergyPurchase(
            provider_id=provider.id if preferred_provider else None,
            energy_amount=energy_amount,
            price_per_energy=best_offer["price"],
            total_cost=best_offer["price"] * energy_amount,
            payment_currency="TRX",
            status=PurchaseStatus.PENDING,
            purchase_type="manual",
            requested_by=requested_by,
            margin_rate=margin,
            resale_price=best_offer["price"] * (1 + margin),
            trigger_reason=f"manual:{urgency}"
        )
        
        self.db.add(purchase)
        self.db.commit()
        
        return purchase
        
    async def approve_purchase(
        self,
        purchase_id: int,
        approved_by: int
    ) -> ExternalEnergyPurchase:
        """êµ¬ë§¤ ìŠ¹ì¸"""
        purchase = self.db.query(ExternalEnergyPurchase).filter(
            ExternalEnergyPurchase.id == purchase_id,
            ExternalEnergyPurchase.status == PurchaseStatus.PENDING
        ).first()
        
        if not purchase:
            raise ValueError("Purchase not found or already processed")
            
        purchase.status = PurchaseStatus.APPROVED
        purchase.approved_by = approved_by
        purchase.approved_at = datetime.utcnow()
        
        self.db.commit()
        
        # ìë™ìœ¼ë¡œ êµ¬ë§¤ ì‹¤í–‰
        await self._process_purchase(purchase)
        
        return purchase
```

### Phase 3: API ì—”ë“œí¬ì¸íŠ¸ êµ¬í˜„ (2ì¼)

#### 3.1 ìŠˆí¼ ì–´ë“œë¯¼ API
```python
# app/api/v1/endpoints/admin/external_energy.py
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from typing import List, Optional
from decimal import Decimal
from app.api import deps
from app.schemas.external_energy import (
    ProviderResponse, PriceComparisonResponse,
    PurchaseRequest, PurchaseResponse,
    PurchaseRuleCreate, PurchaseRuleResponse
)

router = APIRouter()

@router.get("/providers", response_model=List[ProviderResponse])
async def get_energy_providers(
    active_only: bool = True,
    current_user=Depends(deps.get_current_superadmin),
    db: Session = Depends(deps.get_db)
):
    """ì™¸ë¶€ ì—ë„ˆì§€ ê³µê¸‰ì ëª©ë¡ ì¡°íšŒ"""
    query = db.query(ExternalEnergyProvider)
    if active_only:
        query = query.filter(ExternalEnergyProvider.is_active == True)
    
    providers = query.order_by(ExternalEnergyProvider.priority).all()
    return providers

@router.get("/prices/compare", response_model=PriceComparisonResponse)
async def compare_energy_prices(
    amount: int = Query(..., description="í•„ìš”í•œ ì—ë„ˆì§€ëŸ‰"),
    current_user=Depends(deps.get_current_superadmin),
    db: Session = Depends(deps.get_db)
):
    """ê³µê¸‰ìë³„ ê°€ê²© ë¹„êµ"""
    price_monitor = EnergyPriceMonitor(db)
    prices = await price_monitor.fetch_current_prices()
    
    comparisons = []
    for provider_type, price_info in prices.items():
        if price_info["available"] >= amount:
            comparisons.append({
                "provider": provider_type,
                "price_per_energy": price_info["price"],
                "total_cost": price_info["price"] * amount,
                "available": price_info["available"],
                "estimated_time": price_info.get("estimated_time", "ì¦‰ì‹œ")
            })
    
    # ê°€ê²©ìˆœ ì •ë ¬
    comparisons.sort(key=lambda x: x["total_cost"])
    
    return {
        "requested_amount": amount,
        "comparisons": comparisons,
        "best_offer": comparisons[0] if comparisons else None
    }

@router.post("/purchase/manual", response_model=PurchaseResponse)
async def create_manual_purchase(
    request: PurchaseRequest,
    current_user=Depends(deps.get_current_superadmin),
    db: Session = Depends(deps.get_db)
):
    """ìˆ˜ë™ êµ¬ë§¤ ìš”ì²­ ìƒì„±"""
    service = ManualPurchaseService(db, EnergyPriceMonitor(db))
    
    purchase = await service.create_purchase_request(
        requested_by=current_user.id,
        energy_amount=request.energy_amount,
        max_price=request.max_price,
        preferred_provider=request.preferred_provider,
        urgency=request.urgency
    )
    
    return purchase

@router.post("/purchase/{purchase_id}/approve", response_model=PurchaseResponse)
async def approve_purchase(
    purchase_id: int,
    current_user=Depends(deps.get_current_superadmin),
    db: Session = Depends(deps.get_db)
):
    """êµ¬ë§¤ ìŠ¹ì¸"""
    service = ManualPurchaseService(db, EnergyPriceMonitor(db))
    
    purchase = await service.approve_purchase(
        purchase_id=purchase_id,
        approved_by=current_user.id
    )
    
    return purchase

@router.get("/purchases", response_model=List[PurchaseResponse])
async def get_purchase_history(
    status: Optional[PurchaseStatus] = None,
    provider_type: Optional[EnergyProviderType] = None,
    skip: int = 0,
    limit: int = 50,
    current_user=Depends(deps.get_current_superadmin),
    db: Session = Depends(deps.get_db)
):
    """êµ¬ë§¤ ì´ë ¥ ì¡°íšŒ"""
    query = db.query(ExternalEnergyPurchase)
    
    if status:
        query = query.filter(ExternalEnergyPurchase.status == status)
    if provider_type:
        query = query.join(ExternalEnergyProvider).filter(
            ExternalEnergyProvider.provider_type == provider_type
        )
    
    purchases = query.order_by(
        ExternalEnergyPurchase.created_at.desc()
    ).offset(skip).limit(limit).all()
    
    return purchases

# ìë™ êµ¬ë§¤ ê·œì¹™ ê´€ë¦¬
@router.get("/rules", response_model=List[PurchaseRuleResponse])
async def get_purchase_rules(
    active_only: bool = True,
    current_user=Depends(deps.get_current_superadmin),
    db: Session = Depends(deps.get_db)
):
    """ìë™ êµ¬ë§¤ ê·œì¹™ ëª©ë¡"""
    query = db.query(EnergyPurchaseRule)
    if active_only:
        query = query.filter(EnergyPurchaseRule.is_active == True)
    
    rules = query.order_by(EnergyPurchaseRule.priority).all()
    return rules

@router.post("/rules", response_model=PurchaseRuleResponse)
async def create_purchase_rule(
    rule_data: PurchaseRuleCreate,
    current_user=Depends(deps.get_current_superadmin),
    db: Session = Depends(deps.get_db)
):
    """ìë™ êµ¬ë§¤ ê·œì¹™ ìƒì„±"""
    rule = EnergyPurchaseRule(**rule_data.dict())
    db.add(rule)
    db.commit()
    return rule

@router.put("/rules/{rule_id}/toggle")
async def toggle_purchase_rule(
    rule_id: int,
    current_user=Depends(deps.get_current_superadmin),
    db: Session = Depends(deps.get_db)
):
    """ê·œì¹™ í™œì„±í™”/ë¹„í™œì„±í™”"""
    rule = db.query(EnergyPurchaseRule).filter(
        EnergyPurchaseRule.id == rule_id
    ).first()
    
    if not rule:
        raise HTTPException(status_code=404, detail="Rule not found")
    
    rule.is_active = not rule.is_active
    db.commit()
    
    return {"message": f"Rule {'activated' if rule.is_active else 'deactivated'}"}
```

#### 3.2 ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ API
```python
@router.get("/dashboard/overview")
async def get_external_energy_dashboard(
    current_user=Depends(deps.get_current_superadmin),
    db: Session = Depends(deps.get_db)
):
    """ì™¸ë¶€ ì—ë„ˆì§€ êµ¬ë§¤ ëŒ€ì‹œë³´ë“œ"""
    # ì˜¤ëŠ˜ì˜ êµ¬ë§¤ í˜„í™©
    today_start = datetime.utcnow().replace(hour=0, minute=0, second=0)
    
    today_purchases = db.query(
        func.count(ExternalEnergyPurchase.id).label("count"),
        func.sum(ExternalEnergyPurchase.energy_amount).label("total_energy"),
        func.sum(ExternalEnergyPurchase.total_cost).label("total_cost")
    ).filter(
        ExternalEnergyPurchase.created_at >= today_start,
        ExternalEnergyPurchase.status == PurchaseStatus.COMPLETED
    ).first()
    
    # ê³µê¸‰ìë³„ í†µê³„
    provider_stats = db.query(
        ExternalEnergyProvider.name,
        func.count(ExternalEnergyPurchase.id).label("purchase_count"),
        func.avg(ExternalEnergyPurchase.price_per_energy).label("avg_price")
    ).join(
        ExternalEnergyPurchase
    ).filter(
        ExternalEnergyPurchase.created_at >= today_start - timedelta(days=7)
    ).group_by(
        ExternalEnergyProvider.id
    ).all()
    
    # ìë™ êµ¬ë§¤ ì„±ê³µë¥ 
    auto_purchases = db.query(
        func.count(ExternalEnergyPurchase.id).label("total"),
        func.sum(
            case([(ExternalEnergyPurchase.status == PurchaseStatus.COMPLETED, 1)], else_=0)
        ).label("success")
    ).filter(
        ExternalEnergyPurchase.purchase_type == "auto"
    ).first()
    
    success_rate = (auto_purchases.success / auto_purchases.total * 100) if auto_purchases.total > 0 else 0
    
    return {
        "today_summary": {
            "purchases": today_purchases.count or 0,
            "total_energy": today_purchases.total_energy or 0,
            "total_cost": today_purchases.total_cost or 0,
            "average_price": (today_purchases.total_cost / today_purchases.total_energy) 
                           if today_purchases.total_energy else 0
        },
        "provider_performance": provider_stats,
        "automation": {
            "success_rate": success_rate,
            "active_rules": db.query(EnergyPurchaseRule).filter(
                EnergyPurchaseRule.is_active == True
            ).count()
        }
    }
```

### Phase 4: ìë™í™” ë° ìŠ¤ì¼€ì¤„ëŸ¬ (1ì¼)

#### 4.1 ê°€ê²© ëª¨ë‹ˆí„°ë§ ìŠ¤ì¼€ì¤„ëŸ¬
```python
# app/services/schedulers/energy_price_scheduler.py
from apscheduler.schedulers.asyncio import AsyncIOScheduler
import logging

logger = logging.getLogger(__name__)

class EnergyPriceScheduler:
    def __init__(self):
        self.scheduler = AsyncIOScheduler()
        
    def start(self):
        # 5ë¶„ë§ˆë‹¤ ê°€ê²© ì²´í¬
        self.scheduler.add_job(
            self.check_prices,
            'interval',
            minutes=5,
            id='check_energy_prices'
        )
        
        # 1ì‹œê°„ë§ˆë‹¤ ê°€ê²© íˆìŠ¤í† ë¦¬ ê¸°ë¡
        self.scheduler.add_job(
            self.record_price_history,
            'interval',
            hours=1,
            id='record_price_history'
        )
        
        # 10ë¶„ë§ˆë‹¤ ìë™ êµ¬ë§¤ ê·œì¹™ ì²´í¬
        self.scheduler.add_job(
            self.check_auto_purchase_rules,
            'interval',
            minutes=10,
            id='check_auto_purchase_rules'
        )
        
        # ë§¤ì¼ ìì •ì— ê·œì¹™ ì¹´ìš´í„° ë¦¬ì…‹
        self.scheduler.add_job(
            self.reset_daily_counters,
            'cron',
            hour=0,
            minute=0,
            id='reset_daily_counters'
        )
        
        self.scheduler.start()
        logger.info("Energy price scheduler started")
        
    async def check_prices(self):
        """ê°€ê²© ì²´í¬ ë° ì•Œë¦¼"""
        with get_db() as db:
            monitor = EnergyPriceMonitor(db)
            prices = await monitor.fetch_current_prices()
            
            # ê°€ê²© ê¸‰ë“± ì•Œë¦¼
            for provider_type, price_info in prices.items():
                provider = db.query(ExternalEnergyProvider).filter(
                    ExternalEnergyProvider.provider_type == provider_type
                ).first()
                
                if provider.last_price:
                    price_change = ((price_info["price"] - provider.last_price) / 
                                   provider.last_price * 100)
                    
                    if price_change > 20:  # 20% ì´ìƒ ìƒìŠ¹
                        await send_alert(
                            "ENERGY_PRICE_SURGE",
                            f"{provider.name} ê°€ê²© ê¸‰ë“±: {price_change:.1f}%"
                        )
                        
    async def check_auto_purchase_rules(self):
        """ìë™ êµ¬ë§¤ ê·œì¹™ ì‹¤í–‰"""
        with get_db() as db:
            engine = AutoPurchaseEngine(db, EnergyPriceMonitor(db))
            purchases = await engine.check_and_execute_rules()
            
            if purchases:
                logger.info(f"Executed {len(purchases)} auto purchases")
                
    async def reset_daily_counters(self):
        """ì¼ì¼ ì¹´ìš´í„° ë¦¬ì…‹"""
        with get_db() as db:
            db.query(EnergyPurchaseRule).update({
                "daily_execution_count": 0
            })
            db.commit()
```

## ğŸ“Š ë§ˆì§„ ê´€ë¦¬ ë° ìˆ˜ìµì„± ë¶„ì„

### ë™ì  ë§ˆì§„ ì „ëµ
```python
class MarginCalculator:
    """ë™ì  ë§ˆì§„ ê³„ì‚°"""
    
    BASE_MARGINS = {
        "normal": 0.20,      # í‰ìƒì‹œ 20%
        "low_energy": 0.35,  # ì—ë„ˆì§€ ë¶€ì¡± ì‹œ 35%
        "emergency": 0.50,   # ê¸´ê¸‰ ìƒí™© 50%
        "bulk": 0.15        # ëŒ€ëŸ‰ êµ¬ë§¤ 15%
    }
    
    def calculate_margin(self, context: Dict) -> Decimal:
        # ì—ë„ˆì§€ ìˆ˜ì¤€ì— ë”°ë¥¸ ë§ˆì§„
        energy_level = context.get("energy_level_percentage", 50)
        if energy_level < 10:
            base_margin = self.BASE_MARGINS["emergency"]
        elif energy_level < 30:
            base_margin = self.BASE_MARGINS["low_energy"]
        else:
            base_margin = self.BASE_MARGINS["normal"]
            
        # êµ¬ë§¤ëŸ‰ì— ë”°ë¥¸ ì¡°ì •
        amount = context.get("amount", 0)
        if amount > 10000000:  # 1000ë§Œ ì—ë„ˆì§€ ì´ìƒ
            base_margin = min(base_margin, self.BASE_MARGINS["bulk"])
            
        # ì‹œê°„ëŒ€ë³„ ì¡°ì • (í”¼í¬ ì‹œê°„ ì¶”ê°€ ë§ˆì§„)
        current_hour = datetime.utcnow().hour
        if 18 <= current_hour <= 22:  # í”¼í¬ ì‹œê°„
            base_margin *= 1.2
            
        return Decimal(str(base_margin))
```

## âœ… ê²€ì¦ í¬ì¸íŠ¸

### ê¸°ëŠ¥ ê²€ì¦
- [ ] ì™¸ë¶€ ê³µê¸‰ì API ì—°ë™ì´ ì •ìƒ ì‘ë™í•˜ëŠ”ê°€?
- [ ] ê°€ê²© ë¹„êµ ë° ìµœì  ê³µê¸‰ì ì„ íƒì´ ì‘ë™í•˜ëŠ”ê°€?
- [ ] ìë™ êµ¬ë§¤ ê·œì¹™ì´ ì •í™•íˆ ì‹¤í–‰ë˜ëŠ”ê°€?
- [ ] ìˆ˜ë™ êµ¬ë§¤ ìŠ¹ì¸ í”„ë¡œì„¸ìŠ¤ê°€ ì‘ë™í•˜ëŠ”ê°€?
- [ ] ë§ˆì§„ì´ ì •í™•íˆ ê³„ì‚°ë˜ê³  ì ìš©ë˜ëŠ”ê°€?

### ì•ˆì •ì„± ê²€ì¦
- [ ] API ì¥ì•  ì‹œ í´ë°± ì²˜ë¦¬ê°€ ë˜ëŠ”ê°€?
- [ ] ì¤‘ë³µ êµ¬ë§¤ê°€ ë°©ì§€ë˜ëŠ”ê°€?
- [ ] íŠ¸ëœì­ì…˜ ì‹¤íŒ¨ ì‹œ ë¡¤ë°±ì´ ë˜ëŠ”ê°€?
- [ ] ê°€ê²© ê¸‰ë“± ì‹œ ì•Œë¦¼ì´ ë°œì†¡ë˜ëŠ”ê°€?

### ì„±ëŠ¥ ê²€ì¦
- [ ] ë™ì‹œ ë‹¤ë°œì  êµ¬ë§¤ ìš”ì²­ì„ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ”ê°€?
- [ ] ê°€ê²© ì¡°íšŒê°€ 5ì´ˆ ë‚´ì— ì™„ë£Œë˜ëŠ”ê°€?
- [ ] ìŠ¤ì¼€ì¤„ëŸ¬ê°€ ì•ˆì •ì ìœ¼ë¡œ ì‘ë™í•˜ëŠ”ê°€?

## ğŸ‰ ê¸°ëŒ€ íš¨ê³¼

1. **ì„œë¹„ìŠ¤ ì•ˆì •ì„±**: ì—ë„ˆì§€ ë¶€ì¡±ìœ¼ë¡œ ì¸í•œ ì„œë¹„ìŠ¤ ì¤‘ë‹¨ ë°©ì§€
2. **ë¹„ìš© ìµœì í™”**: ì—¬ëŸ¬ ê³µê¸‰ì ì¤‘ ìµœì  ê°€ê²© ì„ íƒ
3. **ìˆ˜ìµ ì°½ì¶œ**: ë§ˆì§„ì„ í†µí•œ ì¶”ê°€ ìˆ˜ìµ
4. **ìë™í™”**: 24/7 ìë™ ì—ë„ˆì§€ ê´€ë¦¬
5. **ë¦¬ìŠ¤í¬ ê´€ë¦¬**: ê°€ê²© ê¸‰ë“± ë° ê³µê¸‰ ë¶€ì¡± ëŒ€ì‘

ì´ ì‹œìŠ¤í…œì„ í†µí•´ ì•ˆì •ì ì¸ ì—ë„ˆì§€ ê³µê¸‰ê³¼ ì¶”ê°€ ìˆ˜ìµì„ ë™ì‹œì— ë‹¬ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!