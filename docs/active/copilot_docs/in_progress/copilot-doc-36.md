# Copilot ë¬¸ì„œ #36: íŠ¸ë¡  ì—ë„ˆì§€ ë Œíƒˆ ì„œë¹„ìŠ¤ êµ¬í˜„

## ëª©í‘œ
ë³¸ì‚¬ê°€ íŒŒíŠ¸ë„ˆì‚¬ì—ê²Œ TRON ì—ë„ˆì§€ë¥¼ ë Œíƒˆí•˜ëŠ” ì„œë¹„ìŠ¤ë¥¼ êµ¬ì¶•í•©ë‹ˆë‹¤. íŒŒíŠ¸ë„ˆì‚¬ëŠ” ì´ˆê¸° TRX ìŠ¤í…Œì´í‚¹ ì—†ì´ë„ ì‚¬ìš©í•œ ë§Œí¼ë§Œ ì—ë„ˆì§€ ë¹„ìš©ì„ ì§€ë¶ˆí•˜ë©°, ë³¸ì‚¬ëŠ” ê·œëª¨ì˜ ê²½ì œë¥¼ í†µí•´ ì•ˆì •ì ì¸ ìˆ˜ìµì„ ì°½ì¶œí•©ë‹ˆë‹¤.

## ì „ì œ ì¡°ê±´
- Copilot ë¬¸ì„œ #1-35ê°€ ì™„ë£Œë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤
- íŒŒíŠ¸ë„ˆì‚¬ ê´€ë¦¬ ì‹œìŠ¤í…œì´ êµ¬ì¶•ë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤
- ì—ë„ˆì§€ í’€ ê´€ë¦¬ ì‹œìŠ¤í…œì´ êµ¬í˜„ë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤
- TRON ë„¤íŠ¸ì›Œí¬ ì—°ë™ì´ ì™„ë£Œë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤

## ğŸ¯ ì—ë„ˆì§€ ë Œíƒˆ ì„œë¹„ìŠ¤ êµ¬ì¡°

### ğŸ“Š ë¹„ì¦ˆë‹ˆìŠ¤ ëª¨ë¸
```
ì—ë„ˆì§€ ë Œíƒˆ ì„œë¹„ìŠ¤
â”œâ”€â”€ ğŸ’° ê°€ê²© ì •ì±…
â”‚   â”œâ”€â”€ ì¢…ëŸ‰ì œ (ì‚¬ìš©ëŸ‰ ê¸°ë°˜)
â”‚   â”œâ”€â”€ êµ¬ë…ì œ (ì›”ì •ì•¡)
â”‚   â”œâ”€â”€ í•˜ì´ë¸Œë¦¬ë“œ (ê¸°ë³¸+ì¶”ê°€)
â”‚   â””â”€â”€ ëŒ€ëŸ‰ í• ì¸ ì •ì±…
â”œâ”€â”€ ğŸ”‹ ì—ë„ˆì§€ ê´€ë¦¬
â”‚   â”œâ”€â”€ ë³¸ì‚¬ ì—ë„ˆì§€ í’€
â”‚   â”œâ”€â”€ íŒŒíŠ¸ë„ˆë³„ í• ë‹¹ëŸ‰
â”‚   â”œâ”€â”€ ì‹¤ì‹œê°„ ì‚¬ìš©ëŸ‰ ì¶”ì 
â”‚   â””â”€â”€ ìë™ ì¬ì¶©ì „ ì‹œìŠ¤í…œ
â”œâ”€â”€ ğŸ’³ ê³¼ê¸ˆ ì‹œìŠ¤í…œ
â”‚   â”œâ”€â”€ ì‹¤ì‹œê°„ ì°¨ê°
â”‚   â”œâ”€â”€ ì¼ê´„ ì •ì‚°
â”‚   â”œâ”€â”€ ì„ ë¶ˆ/í›„ë¶ˆ ì˜µì…˜
â”‚   â””â”€â”€ ìë™ ê²°ì œ
â”œâ”€â”€ ğŸ“Š ëª¨ë‹ˆí„°ë§
â”‚   â”œâ”€â”€ ì‚¬ìš©ëŸ‰ ëŒ€ì‹œë³´ë“œ
â”‚   â”œâ”€â”€ ë¹„ìš© ë¶„ì„
â”‚   â”œâ”€â”€ ì˜ˆì¸¡ ëª¨ë¸
â”‚   â””â”€â”€ ì•Œë¦¼ ì‹œìŠ¤í…œ
â””â”€â”€ ğŸ›¡ï¸ ë¦¬ìŠ¤í¬ ê´€ë¦¬
    â”œâ”€â”€ ì—ë„ˆì§€ ë¶€ì¡± ëŒ€ì‘
    â”œâ”€â”€ ê°€ê²© ë³€ë™ í—¤ì§•
    â”œâ”€â”€ ë¯¸ìˆ˜ê¸ˆ ê´€ë¦¬
    â””â”€â”€ SLA ë³´ì¥
```

## ğŸ› ï¸ êµ¬í˜„ ë‹¨ê³„

### Phase 1: ì—ë„ˆì§€ ë Œíƒˆ ëª¨ë¸ ì„¤ê³„ (2ì¼)

#### 1.1 ë°ì´í„°ë² ì´ìŠ¤ ëª¨ë¸
```python
# app/models/energy_rental.py
from sqlalchemy import Column, Integer, String, Numeric, DateTime, Boolean, Enum, ForeignKey, JSON
from sqlalchemy.orm import relationship
from decimal import Decimal
import enum

class RentalPlanType(enum.Enum):
    """ë Œíƒˆ í”Œëœ ìœ í˜•"""
    PAY_AS_YOU_GO = "pay_as_you_go"  # ì¢…ëŸ‰ì œ
    SUBSCRIPTION = "subscription"      # êµ¬ë…ì œ
    HYBRID = "hybrid"                 # í•˜ì´ë¸Œë¦¬ë“œ

class SubscriptionTier(enum.Enum):
    """êµ¬ë… ë“±ê¸‰"""
    BRONZE = "bronze"    # ì›” 50ë§Œ ì—ë„ˆì§€
    SILVER = "silver"    # ì›” 500ë§Œ ì—ë„ˆì§€
    GOLD = "gold"       # ì›” 5000ë§Œ ì—ë„ˆì§€
    ENTERPRISE = "enterprise"  # ë¬´ì œí•œ

class EnergyRentalPlan(Base):
    """ì—ë„ˆì§€ ë Œíƒˆ í”Œëœ"""
    __tablename__ = "energy_rental_plans"
    
    id = Column(Integer, primary_key=True)
    partner_id = Column(Integer, ForeignKey("partners.id"), nullable=False)
    plan_type = Column(Enum(RentalPlanType), nullable=False)
    subscription_tier = Column(Enum(SubscriptionTier))
    
    # ê°€ê²© ì„¤ì •
    price_per_energy = Column(Numeric(20, 10), default=Decimal("0.00008"))  # TRX per ì—ë„ˆì§€
    monthly_fee = Column(Numeric(20, 6))  # ì›” êµ¬ë…ë£Œ
    
    # í• ë‹¹ëŸ‰ ë° ì‚¬ìš©ëŸ‰
    monthly_energy_quota = Column(Integer, default=0)
    monthly_energy_used = Column(Integer, default=0)
    daily_limit = Column(Integer)
    
    # í• ì¸ ë° í”„ë¡œëª¨ì…˜
    discount_rate = Column(Numeric(5, 4), default=Decimal("0"))
    promotional_end_date = Column(DateTime)
    
    # ê²°ì œ ì„¤ì •
    payment_method = Column(String(50))  # "prepaid", "postpaid"
    auto_recharge_enabled = Column(Boolean, default=False)
    auto_recharge_threshold = Column(Integer)  # ì”ì—¬ ì—ë„ˆì§€ ì„ê³„ê°’
    
    # ìƒíƒœ
    is_active = Column(Boolean, default=True)
    activated_at = Column(DateTime)
    expires_at = Column(DateTime)
    
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # ê´€ê³„
    partner = relationship("Partner", back_populates="energy_rental_plan")
    usage_records = relationship("EnergyUsageRecord", back_populates="rental_plan")
    settlements = relationship("EnergySettlement", back_populates="rental_plan")

class EnergyUsageRecord(Base):
    """ì—ë„ˆì§€ ì‚¬ìš© ê¸°ë¡"""
    __tablename__ = "energy_usage_records"
    
    id = Column(Integer, primary_key=True)
    rental_plan_id = Column(Integer, ForeignKey("energy_rental_plans.id"))
    transaction_id = Column(Integer, ForeignKey("transactions.id"))
    
    energy_used = Column(Integer, nullable=False)
    price_per_energy = Column(Numeric(20, 10), nullable=False)
    total_cost = Column(Numeric(20, 6), nullable=False)
    
    # ë¹„ìš© ì²˜ë¦¬
    payment_status = Column(String(20), default="pending")  # pending, charged, failed
    payment_method = Column(String(20))  # "trx", "usdt"
    charged_at = Column(DateTime)
    
    created_at = Column(DateTime, default=datetime.utcnow)
    
    # ê´€ê³„
    rental_plan = relationship("EnergyRentalPlan", back_populates="usage_records")
    transaction = relationship("Transaction")

class EnergySettlement(Base):
    """ì—ë„ˆì§€ ì •ì‚°"""
    __tablename__ = "energy_settlements"
    
    id = Column(Integer, primary_key=True)
    rental_plan_id = Column(Integer, ForeignKey("energy_rental_plans.id"))
    
    settlement_type = Column(String(20))  # "daily", "weekly", "monthly"
    period_start = Column(DateTime, nullable=False)
    period_end = Column(DateTime, nullable=False)
    
    # ì‚¬ìš©ëŸ‰ ë° ë¹„ìš©
    total_energy_used = Column(Integer, nullable=False)
    base_cost = Column(Numeric(20, 6), nullable=False)
    discount_amount = Column(Numeric(20, 6), default=Decimal("0"))
    final_cost = Column(Numeric(20, 6), nullable=False)
    
    # ê²°ì œ ì •ë³´
    payment_status = Column(String(20), default="pending")
    payment_method = Column(String(20))
    payment_tx_hash = Column(String(64))
    paid_at = Column(DateTime)
    
    created_at = Column(DateTime, default=datetime.utcnow)
    
    # ê´€ê³„
    rental_plan = relationship("EnergyRentalPlan", back_populates="settlements")

class EnergyPricing(Base):
    """ì—ë„ˆì§€ ê°€ê²© ì •ì±…"""
    __tablename__ = "energy_pricing"
    
    id = Column(Integer, primary_key=True)
    tier_name = Column(String(50), unique=True)
    min_volume = Column(Integer, nullable=False)  # ìµœì†Œ ì‚¬ìš©ëŸ‰
    max_volume = Column(Integer)  # ìµœëŒ€ ì‚¬ìš©ëŸ‰ (NULL = ë¬´ì œí•œ)
    price_per_energy = Column(Numeric(20, 10), nullable=False)
    
    # ì‹œê°„ëŒ€ë³„ ê°€ê²©
    peak_hour_multiplier = Column(Numeric(3, 2), default=Decimal("1.0"))
    off_peak_discount = Column(Numeric(3, 2), default=Decimal("0"))
    
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
```

### Phase 2: ì—ë„ˆì§€ ë Œíƒˆ ì„œë¹„ìŠ¤ êµ¬í˜„ (2ì¼)

#### 2.1 ì—ë„ˆì§€ ë Œíƒˆ ì„œë¹„ìŠ¤
```python
# app/services/energy_rental_service.py
from typing import Optional, List, Dict
from decimal import Decimal
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from app.models.energy_rental import (
    EnergyRentalPlan, EnergyUsageRecord, 
    EnergySettlement, RentalPlanType, SubscriptionTier
)
from app.core.exceptions import InsufficientEnergyError, PaymentError

class EnergyRentalService:
    def __init__(self, db: Session):
        self.db = db
        
    # í”Œëœ ê´€ë¦¬
    async def create_rental_plan(
        self, 
        partner_id: int, 
        plan_type: RentalPlanType,
        subscription_tier: Optional[SubscriptionTier] = None
    ) -> EnergyRentalPlan:
        """ë Œíƒˆ í”Œëœ ìƒì„±"""
        # ê¸°ì¡´ í”Œëœ í™•ì¸
        existing = self.db.query(EnergyRentalPlan).filter(
            EnergyRentalPlan.partner_id == partner_id,
            EnergyRentalPlan.is_active == True
        ).first()
        
        if existing:
            existing.is_active = False
            
        # ê°€ê²© ë° í• ë‹¹ëŸ‰ ì„¤ì •
        pricing = self._get_pricing_for_tier(subscription_tier)
        
        plan = EnergyRentalPlan(
            partner_id=partner_id,
            plan_type=plan_type,
            subscription_tier=subscription_tier,
            price_per_energy=pricing["price_per_energy"],
            monthly_fee=pricing.get("monthly_fee", 0),
            monthly_energy_quota=pricing.get("quota", 0),
            activated_at=datetime.utcnow()
        )
        
        if plan_type == RentalPlanType.SUBSCRIPTION:
            plan.expires_at = datetime.utcnow() + timedelta(days=30)
            
        self.db.add(plan)
        self.db.commit()
        return plan
        
    def _get_pricing_for_tier(self, tier: Optional[SubscriptionTier]) -> Dict:
        """ë“±ê¸‰ë³„ ê°€ê²© ì •ë³´"""
        pricing_map = {
            SubscriptionTier.BRONZE: {
                "price_per_energy": Decimal("0.00010"),
                "monthly_fee": Decimal("40"),
                "quota": 500000
            },
            SubscriptionTier.SILVER: {
                "price_per_energy": Decimal("0.00008"),
                "monthly_fee": Decimal("300"),
                "quota": 5000000
            },
            SubscriptionTier.GOLD: {
                "price_per_energy": Decimal("0.00006"),
                "monthly_fee": Decimal("2000"),
                "quota": 50000000
            },
            SubscriptionTier.ENTERPRISE: {
                "price_per_energy": Decimal("0.00005"),
                "monthly_fee": Decimal("10000"),
                "quota": None  # ë¬´ì œí•œ
            }
        }
        
        if tier and tier in pricing_map:
            return pricing_map[tier]
        
        # ì¢…ëŸ‰ì œ ê¸°ë³¸ ê°€ê²©
        return {"price_per_energy": Decimal("0.00010")}
        
    # ì—ë„ˆì§€ ì‚¬ìš© ì²˜ë¦¬
    async def use_energy(
        self, 
        partner_id: int, 
        energy_amount: int,
        transaction_id: Optional[int] = None
    ) -> EnergyUsageRecord:
        """ì—ë„ˆì§€ ì‚¬ìš© ì²˜ë¦¬"""
        # í™œì„± í”Œëœ ì¡°íšŒ
        plan = self.db.query(EnergyRentalPlan).filter(
            EnergyRentalPlan.partner_id == partner_id,
            EnergyRentalPlan.is_active == True
        ).first()
        
        if not plan:
            raise ValueError("í™œì„± ë Œíƒˆ í”Œëœì´ ì—†ìŠµë‹ˆë‹¤")
            
        # ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
        can_use, reason = await self._check_energy_availability(plan, energy_amount)
        if not can_use:
            raise InsufficientEnergyError(reason)
            
        # ë¹„ìš© ê³„ì‚°
        cost = await self._calculate_energy_cost(plan, energy_amount)
        
        # ì‚¬ìš© ê¸°ë¡ ìƒì„±
        usage = EnergyUsageRecord(
            rental_plan_id=plan.id,
            transaction_id=transaction_id,
            energy_used=energy_amount,
            price_per_energy=plan.price_per_energy,
            total_cost=cost
        )
        
        # ì¦‰ì‹œ ì°¨ê° ì²˜ë¦¬ (ì„ ë¶ˆì œ)
        if plan.payment_method == "prepaid":
            charged = await self._charge_energy_cost(partner_id, cost)
            if charged:
                usage.payment_status = "charged"
                usage.charged_at = datetime.utcnow()
            else:
                raise PaymentError("ì—ë„ˆì§€ ë¹„ìš© ì°¨ê° ì‹¤íŒ¨")
                
        # í”Œëœ ì‚¬ìš©ëŸ‰ ì—…ë°ì´íŠ¸
        plan.monthly_energy_used += energy_amount
        
        self.db.add(usage)
        self.db.commit()
        return usage
        
    async def _check_energy_availability(
        self, 
        plan: EnergyRentalPlan, 
        energy_amount: int
    ) -> tuple[bool, Optional[str]]:
        """ì—ë„ˆì§€ ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸"""
        # í”Œëœ ë§Œë£Œ í™•ì¸
        if plan.expires_at and plan.expires_at < datetime.utcnow():
            return False, "ë Œíƒˆ í”Œëœì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤"
            
        # ì¼ì¼ í•œë„ í™•ì¸
        if plan.daily_limit:
            today_usage = self._get_today_usage(plan.id)
            if today_usage + energy_amount > plan.daily_limit:
                return False, "ì¼ì¼ ì‚¬ìš© í•œë„ ì´ˆê³¼"
                
        # êµ¬ë… í”Œëœ í• ë‹¹ëŸ‰ í™•ì¸
        if plan.plan_type == RentalPlanType.SUBSCRIPTION:
            if plan.monthly_energy_quota and \
               plan.monthly_energy_used + energy_amount > plan.monthly_energy_quota:
                return False, "ì›” í• ë‹¹ëŸ‰ ì´ˆê³¼"
                
        # ë³¸ì‚¬ ì—ë„ˆì§€ í’€ í™•ì¸
        available_energy = await self._get_headquarters_energy()
        if available_energy < energy_amount:
            return False, "ë³¸ì‚¬ ì—ë„ˆì§€ í’€ ë¶€ì¡±"
            
        return True, None
        
    async def _calculate_energy_cost(
        self, 
        plan: EnergyRentalPlan, 
        energy_amount: int
    ) -> Decimal:
        """ì—ë„ˆì§€ ë¹„ìš© ê³„ì‚°"""
        # êµ¬ë… í”Œëœì€ í• ë‹¹ëŸ‰ ë‚´ ë¬´ë£Œ
        if plan.plan_type == RentalPlanType.SUBSCRIPTION:
            remaining_quota = plan.monthly_energy_quota - plan.monthly_energy_used
            if energy_amount <= remaining_quota:
                return Decimal("0")
            # ì´ˆê³¼ë¶„ë§Œ ê³¼ê¸ˆ
            billable_amount = energy_amount - remaining_quota
        else:
            billable_amount = energy_amount
            
        # ë³¼ë¥¨ í• ì¸ ì ìš©
        price_per_energy = await self._get_volume_price(
            plan.partner_id, 
            billable_amount
        )
        
        # í”„ë¡œëª¨ì…˜ í• ì¸ ì ìš©
        if plan.discount_rate > 0 and \
           (not plan.promotional_end_date or plan.promotional_end_date > datetime.utcnow()):
            price_per_energy *= (1 - plan.discount_rate)
            
        return Decimal(billable_amount) * price_per_energy
        
    async def _get_volume_price(self, partner_id: int, amount: int) -> Decimal:
        """ë³¼ë¥¨ë³„ ë‹¨ê°€ ì¡°íšŒ"""
        # ì›”ê°„ ì´ ì‚¬ìš©ëŸ‰ ê¸°ì¤€
        monthly_total = self._get_monthly_usage(partner_id)
        total_volume = monthly_total + amount
        
        # ê°€ê²© í…Œì´ë¸”ì—ì„œ ì ìš© ê°€ê²© ì¡°íšŒ
        pricing = self.db.query(EnergyPricing).filter(
            EnergyPricing.is_active == True,
            EnergyPricing.min_volume <= total_volume
        ).order_by(EnergyPricing.min_volume.desc()).first()
        
        if pricing:
            # ì‹œê°„ëŒ€ë³„ ê°€ê²© ì¡°ì •
            current_hour = datetime.utcnow().hour
            if 18 <= current_hour <= 22:  # í”¼í¬ ì‹œê°„
                return pricing.price_per_energy * pricing.peak_hour_multiplier
            elif 0 <= current_hour <= 6:  # ì˜¤í”„í”¼í¬
                return pricing.price_per_energy * (1 - pricing.off_peak_discount)
            return pricing.price_per_energy
            
        return Decimal("0.00010")  # ê¸°ë³¸ê°€
        
    # ì •ì‚° ì²˜ë¦¬
    async def process_settlement(
        self, 
        partner_id: int, 
        settlement_type: str = "daily"
    ) -> EnergySettlement:
        """ì—ë„ˆì§€ ì‚¬ìš© ì •ì‚°"""
        plan = self.db.query(EnergyRentalPlan).filter(
            EnergyRentalPlan.partner_id == partner_id,
            EnergyRentalPlan.is_active == True
        ).first()
        
        if not plan:
            return None
            
        # ì •ì‚° ê¸°ê°„ ì„¤ì •
        period_end = datetime.utcnow()
        if settlement_type == "daily":
            period_start = period_end - timedelta(days=1)
        elif settlement_type == "weekly":
            period_start = period_end - timedelta(days=7)
        else:  # monthly
            period_start = period_end - timedelta(days=30)
            
        # ê¸°ê°„ ë‚´ ì‚¬ìš©ëŸ‰ ì§‘ê³„
        usage_records = self.db.query(EnergyUsageRecord).filter(
            EnergyUsageRecord.rental_plan_id == plan.id,
            EnergyUsageRecord.created_at >= period_start,
            EnergyUsageRecord.created_at < period_end,
            EnergyUsageRecord.payment_status == "pending"
        ).all()
        
        if not usage_records:
            return None
            
        total_energy = sum(u.energy_used for u in usage_records)
        base_cost = sum(u.total_cost for u in usage_records)
        
        # ì¶”ê°€ í• ì¸ ì ìš© (ì¶©ì„±ë„, ì„ ë¶ˆ ë“±)
        discount = await self._calculate_settlement_discount(
            partner_id, 
            base_cost
        )
        
        final_cost = base_cost - discount
        
        # ì •ì‚° ê¸°ë¡ ìƒì„±
        settlement = EnergySettlement(
            rental_plan_id=plan.id,
            settlement_type=settlement_type,
            period_start=period_start,
            period_end=period_end,
            total_energy_used=total_energy,
            base_cost=base_cost,
            discount_amount=discount,
            final_cost=final_cost
        )
        
        # ìë™ ê²°ì œ ì²˜ë¦¬
        if plan.payment_method == "postpaid":
            payment_result = await self._process_settlement_payment(
                partner_id, 
                final_cost
            )
            if payment_result["success"]:
                settlement.payment_status = "paid"
                settlement.payment_method = payment_result["method"]
                settlement.payment_tx_hash = payment_result["tx_hash"]
                settlement.paid_at = datetime.utcnow()
                
                # ì‚¬ìš© ê¸°ë¡ ì—…ë°ì´íŠ¸
                for usage in usage_records:
                    usage.payment_status = "charged"
                    usage.charged_at = datetime.utcnow()
                    
        self.db.add(settlement)
        self.db.commit()
        return settlement
        
    # ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼
    async def check_energy_alerts(self, partner_id: int) -> List[Dict]:
        """ì—ë„ˆì§€ ê´€ë ¨ ì•Œë¦¼ í™•ì¸"""
        alerts = []
        plan = self.db.query(EnergyRentalPlan).filter(
            EnergyRentalPlan.partner_id == partner_id,
            EnergyRentalPlan.is_active == True
        ).first()
        
        if not plan:
            return alerts
            
        # êµ¬ë… ë§Œë£Œ ì„ë°•
        if plan.expires_at:
            days_until_expiry = (plan.expires_at - datetime.utcnow()).days
            if days_until_expiry <= 3:
                alerts.append({
                    "type": "subscription_expiry",
                    "severity": "warning",
                    "message": f"êµ¬ë…ì´ {days_until_expiry}ì¼ í›„ ë§Œë£Œë©ë‹ˆë‹¤",
                    "action": "renew_subscription"
                })
                
        # í• ë‹¹ëŸ‰ ì†Œì§„ ì„ë°•
        if plan.monthly_energy_quota:
            usage_percent = (plan.monthly_energy_used / plan.monthly_energy_quota) * 100
            if usage_percent >= 90:
                alerts.append({
                    "type": "quota_warning",
                    "severity": "warning",
                    "message": f"ì›” í• ë‹¹ëŸ‰ì˜ {usage_percent:.1f}%ë¥¼ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤",
                    "action": "upgrade_plan"
                })
                
        # ë¯¸ê²°ì œ ì •ì‚°
        unpaid_settlements = self.db.query(EnergySettlement).filter(
            EnergySettlement.rental_plan_id == plan.id,
            EnergySettlement.payment_status == "pending"
        ).count()
        
        if unpaid_settlements > 0:
            alerts.append({
                "type": "unpaid_settlement",
                "severity": "critical",
                "message": f"{unpaid_settlements}ê±´ì˜ ë¯¸ê²°ì œ ì •ì‚°ì´ ìˆìŠµë‹ˆë‹¤",
                "action": "pay_settlement"
            })
            
        return alerts
```

### Phase 3: API ì—”ë“œí¬ì¸íŠ¸ êµ¬í˜„ (1ì¼)

#### 3.1 íŒŒíŠ¸ë„ˆìš© ì—ë„ˆì§€ ë Œíƒˆ API
```python
# app/api/v1/endpoints/partner/energy_rental.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List, Optional
from decimal import Decimal
from app.api import deps
from app.schemas.energy_rental import (
    RentalPlanCreate, RentalPlanResponse,
    EnergyUsageRequest, EnergyUsageResponse,
    SettlementResponse, PricingResponse
)
from app.services.energy_rental_service import EnergyRentalService

router = APIRouter()

@router.post("/rental-plans", response_model=RentalPlanResponse)
async def create_rental_plan(
    plan_data: RentalPlanCreate,
    partner_id: int = Depends(deps.get_current_partner_id),
    db: Session = Depends(deps.get_db)
):
    """ì—ë„ˆì§€ ë Œíƒˆ í”Œëœ ìƒì„±/ë³€ê²½"""
    service = EnergyRentalService(db)
    plan = await service.create_rental_plan(
        partner_id=partner_id,
        plan_type=plan_data.plan_type,
        subscription_tier=plan_data.subscription_tier
    )
    return plan

@router.get("/rental-plans/current", response_model=RentalPlanResponse)
async def get_current_plan(
    partner_id: int = Depends(deps.get_current_partner_id),
    db: Session = Depends(deps.get_db)
):
    """í˜„ì¬ í™œì„± ë Œíƒˆ í”Œëœ ì¡°íšŒ"""
    plan = db.query(EnergyRentalPlan).filter(
        EnergyRentalPlan.partner_id == partner_id,
        EnergyRentalPlan.is_active == True
    ).first()
    
    if not plan:
        raise HTTPException(status_code=404, detail="í™œì„± í”Œëœì´ ì—†ìŠµë‹ˆë‹¤")
    
    return plan

@router.get("/pricing", response_model=PricingResponse)
async def get_energy_pricing(
    volume: Optional[int] = None,
    db: Session = Depends(deps.get_db)
):
    """ì—ë„ˆì§€ ê°€ê²© ì •ë³´ ì¡°íšŒ"""
    # ê°€ê²© í…Œì´ë¸” ì¡°íšŒ
    pricing_tiers = db.query(EnergyPricing).filter(
        EnergyPricing.is_active == True
    ).order_by(EnergyPricing.min_volume).all()
    
    # íŠ¹ì • ë³¼ë¥¨ì— ëŒ€í•œ ê°€ê²© ê³„ì‚°
    if volume:
        applicable_tier = None
        for tier in pricing_tiers:
            if tier.min_volume <= volume:
                if not tier.max_volume or volume <= tier.max_volume:
                    applicable_tier = tier
                    break
                    
        if applicable_tier:
            current_hour = datetime.utcnow().hour
            if 18 <= current_hour <= 22:
                price = applicable_tier.price_per_energy * applicable_tier.peak_hour_multiplier
            else:
                price = applicable_tier.price_per_energy
        else:
            price = Decimal("0.00010")
            
        return {
            "volume": volume,
            "price_per_energy": price,
            "total_cost": price * volume,
            "pricing_tiers": pricing_tiers
        }
    
    return {"pricing_tiers": pricing_tiers}

@router.post("/energy/use", response_model=EnergyUsageResponse)
async def use_energy(
    request: EnergyUsageRequest,
    partner_id: int = Depends(deps.get_current_partner_id),
    db: Session = Depends(deps.get_db)
):
    """ì—ë„ˆì§€ ì‚¬ìš© (ì‹¤ì‹œê°„ ì°¨ê°)"""
    service = EnergyRentalService(db)
    
    try:
        usage = await service.use_energy(
            partner_id=partner_id,
            energy_amount=request.energy_amount,
            transaction_id=request.transaction_id
        )
        
        return {
            "usage_id": usage.id,
            "energy_used": usage.energy_used,
            "cost": usage.total_cost,
            "payment_status": usage.payment_status,
            "message": "ì—ë„ˆì§€ê°€ ì„±ê³µì ìœ¼ë¡œ ì‚¬ìš©ë˜ì—ˆìŠµë‹ˆë‹¤"
        }
    except InsufficientEnergyError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except PaymentError as e:
        raise HTTPException(status_code=402, detail=str(e))

@router.get("/usage/history", response_model=List[EnergyUsageResponse])
async def get_usage_history(
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
    partner_id: int = Depends(deps.get_current_partner_id),
    db: Session = Depends(deps.get_db)
):
    """ì—ë„ˆì§€ ì‚¬ìš© ë‚´ì—­ ì¡°íšŒ"""
    query = db.query(EnergyUsageRecord).join(
        EnergyRentalPlan
    ).filter(
        EnergyRentalPlan.partner_id == partner_id
    )
    
    if start_date:
        query = query.filter(EnergyUsageRecord.created_at >= start_date)
    if end_date:
        query = query.filter(EnergyUsageRecord.created_at <= end_date)
        
    usage_records = query.order_by(
        EnergyUsageRecord.created_at.desc()
    ).limit(100).all()
    
    return usage_records

@router.get("/settlements", response_model=List[SettlementResponse])
async def get_settlements(
    status: Optional[str] = None,
    partner_id: int = Depends(deps.get_current_partner_id),
    db: Session = Depends(deps.get_db)
):
    """ì •ì‚° ë‚´ì—­ ì¡°íšŒ"""
    query = db.query(EnergySettlement).join(
        EnergyRentalPlan
    ).filter(
        EnergyRentalPlan.partner_id == partner_id
    )
    
    if status:
        query = query.filter(EnergySettlement.payment_status == status)
        
    settlements = query.order_by(
        EnergySettlement.created_at.desc()
    ).limit(50).all()
    
    return settlements

@router.post("/settlements/{settlement_id}/pay")
async def pay_settlement(
    settlement_id: int,
    payment_method: str,
    partner_id: int = Depends(deps.get_current_partner_id),
    db: Session = Depends(deps.get_db)
):
    """ì •ì‚° ìˆ˜ë™ ê²°ì œ"""
    settlement = db.query(EnergySettlement).join(
        EnergyRentalPlan
    ).filter(
        EnergySettlement.id == settlement_id,
        EnergyRentalPlan.partner_id == partner_id
    ).first()
    
    if not settlement:
        raise HTTPException(status_code=404, detail="ì •ì‚°ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
        
    if settlement.payment_status == "paid":
        raise HTTPException(status_code=400, detail="ì´ë¯¸ ê²°ì œëœ ì •ì‚°ì…ë‹ˆë‹¤")
        
    # ê²°ì œ ì²˜ë¦¬ (ì‹¤ì œ êµ¬í˜„ ì‹œ ê²°ì œ ì„œë¹„ìŠ¤ í˜¸ì¶œ)
    # payment_result = await process_payment(...)
    
    settlement.payment_status = "paid"
    settlement.payment_method = payment_method
    settlement.paid_at = datetime.utcnow()
    
    db.commit()
    
    return {"message": "ì •ì‚°ì´ ì„±ê³µì ìœ¼ë¡œ ê²°ì œë˜ì—ˆìŠµë‹ˆë‹¤"}
```

#### 3.2 ë³¸ì‚¬ ìŠˆí¼ ì–´ë“œë¯¼ API
```python
# app/api/v1/endpoints/admin/energy_rental.py
from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session
from typing import List, Optional
from datetime import datetime, timedelta
from app.api import deps
from app.schemas.energy_rental import (
    EnergyPoolStatus, RentalStatistics,
    PartnerEnergyUsage, RevenueReport
)

router = APIRouter()

@router.get("/energy-pool/status", response_model=EnergyPoolStatus)
async def get_energy_pool_status(
    current_user=Depends(deps.get_current_superadmin),
    db: Session = Depends(deps.get_db)
):
    """ë³¸ì‚¬ ì—ë„ˆì§€ í’€ í˜„í™©"""
    # ì „ì²´ ìŠ¤í…Œì´í‚¹ TRX
    total_staked = db.query(func.sum(EnergyPool.staked_amount)).scalar() or 0
    
    # ì „ì²´ ì—ë„ˆì§€ ìš©ëŸ‰
    total_capacity = total_staked * 1500  # 1 TRX = 1500 ì—ë„ˆì§€
    
    # í˜„ì¬ ì‚¬ìš© ì¤‘ì¸ ì—ë„ˆì§€
    today_usage = db.query(
        func.sum(EnergyUsageRecord.energy_used)
    ).filter(
        EnergyUsageRecord.created_at >= datetime.utcnow().date()
    ).scalar() or 0
    
    # íŒŒíŠ¸ë„ˆë³„ í• ë‹¹ëŸ‰
    partner_allocations = db.query(
        Partner.name,
        func.sum(EnergyUsageRecord.energy_used).label("daily_usage")
    ).join(
        EnergyRentalPlan
    ).join(
        EnergyUsageRecord
    ).filter(
        EnergyUsageRecord.created_at >= datetime.utcnow().date()
    ).group_by(Partner.id).all()
    
    return {
        "total_staked_trx": total_staked,
        "total_energy_capacity": total_capacity,
        "available_energy": total_capacity - today_usage,
        "utilization_rate": (today_usage / total_capacity) * 100 if total_capacity > 0 else 0,
        "partner_allocations": partner_allocations
    }

@router.get("/rental/statistics", response_model=RentalStatistics)
async def get_rental_statistics(
    period: str = Query("daily", regex="^(daily|weekly|monthly)$"),
    current_user=Depends(deps.get_current_superadmin),
    db: Session = Depends(deps.get_db)
):
    """ì—ë„ˆì§€ ë Œíƒˆ í†µê³„"""
    # ê¸°ê°„ ì„¤ì •
    if period == "daily":
        start_date = datetime.utcnow() - timedelta(days=1)
    elif period == "weekly":
        start_date = datetime.utcnow() - timedelta(days=7)
    else:
        start_date = datetime.utcnow() - timedelta(days=30)
        
    # ì´ ë Œíƒˆ ìˆ˜ìµ
    total_revenue = db.query(
        func.sum(EnergyUsageRecord.total_cost)
    ).filter(
        EnergyUsageRecord.created_at >= start_date,
        EnergyUsageRecord.payment_status == "charged"
    ).scalar() or 0
    
    # ì´ ì—ë„ˆì§€ ì‚¬ìš©ëŸ‰
    total_energy_used = db.query(
        func.sum(EnergyUsageRecord.energy_used)
    ).filter(
        EnergyUsageRecord.created_at >= start_date
    ).scalar() or 0
    
    # í™œì„± íŒŒíŠ¸ë„ˆ ìˆ˜
    active_partners = db.query(
        func.count(func.distinct(EnergyRentalPlan.partner_id))
    ).filter(
        EnergyRentalPlan.is_active == True
    ).scalar() or 0
    
    # í”Œëœë³„ ë¶„í¬
    plan_distribution = db.query(
        EnergyRentalPlan.plan_type,
        func.count(EnergyRentalPlan.id).label("count")
    ).filter(
        EnergyRentalPlan.is_active == True
    ).group_by(EnergyRentalPlan.plan_type).all()
    
    return {
        "period": period,
        "total_revenue": total_revenue,
        "total_energy_used": total_energy_used,
        "average_price_per_energy": total_revenue / total_energy_used if total_energy_used > 0 else 0,
        "active_partners": active_partners,
        "plan_distribution": plan_distribution
    }

@router.get("/partners/{partner_id}/energy-usage", response_model=PartnerEnergyUsage)
async def get_partner_energy_usage(
    partner_id: int,
    current_user=Depends(deps.get_current_superadmin),
    db: Session = Depends(deps.get_db)
):
    """íŠ¹ì • íŒŒíŠ¸ë„ˆì‚¬ ì—ë„ˆì§€ ì‚¬ìš© í˜„í™©"""
    # í˜„ì¬ í”Œëœ
    current_plan = db.query(EnergyRentalPlan).filter(
        EnergyRentalPlan.partner_id == partner_id,
        EnergyRentalPlan.is_active == True
    ).first()
    
    if not current_plan:
        raise HTTPException(status_code=404, detail="í™œì„± í”Œëœì´ ì—†ìŠµë‹ˆë‹¤")
        
    # ì´ë²ˆ ë‹¬ ì‚¬ìš©ëŸ‰
    month_start = datetime.utcnow().replace(day=1, hour=0, minute=0, second=0)
    monthly_usage = db.query(
        func.sum(EnergyUsageRecord.energy_used)
    ).filter(
        EnergyUsageRecord.rental_plan_id == current_plan.id,
        EnergyUsageRecord.created_at >= month_start
    ).scalar() or 0
    
    # ì´ë²ˆ ë‹¬ ë¹„ìš©
    monthly_cost = db.query(
        func.sum(EnergyUsageRecord.total_cost)
    ).filter(
        EnergyUsageRecord.rental_plan_id == current_plan.id,
        EnergyUsageRecord.created_at >= month_start
    ).scalar() or 0
    
    # ë¯¸ê²°ì œ ê¸ˆì•¡
    unpaid_amount = db.query(
        func.sum(EnergySettlement.final_cost)
    ).filter(
        EnergySettlement.rental_plan_id == current_plan.id,
        EnergySettlement.payment_status == "pending"
    ).scalar() or 0
    
    return {
        "partner_id": partner_id,
        "current_plan": current_plan,
        "monthly_usage": monthly_usage,
        "monthly_cost": monthly_cost,
        "unpaid_amount": unpaid_amount,
        "usage_percentage": (monthly_usage / current_plan.monthly_energy_quota * 100) 
                           if current_plan.monthly_energy_quota else None
    }

@router.post("/energy-pool/recharge")
async def recharge_energy_pool(
    amount_trx: int,
    current_user=Depends(deps.get_current_superadmin),
    db: Session = Depends(deps.get_db)
):
    """ì—ë„ˆì§€ í’€ ì¶©ì „ (TRX ìŠ¤í…Œì´í‚¹)"""
    # ì‹¤ì œ ìŠ¤í…Œì´í‚¹ ì²˜ë¦¬
    # staking_result = await stake_trx(amount_trx)
    
    # ì—ë„ˆì§€ í’€ ì—…ë°ì´íŠ¸
    energy_pool = db.query(EnergyPool).first()
    if not energy_pool:
        energy_pool = EnergyPool(staked_amount=0)
        db.add(energy_pool)
        
    energy_pool.staked_amount += amount_trx
    energy_pool.last_recharged_at = datetime.utcnow()
    
    db.commit()
    
    return {
        "message": f"{amount_trx} TRXê°€ ì„±ê³µì ìœ¼ë¡œ ìŠ¤í…Œì´í‚¹ë˜ì—ˆìŠµë‹ˆë‹¤",
        "new_total": energy_pool.staked_amount,
        "additional_energy": amount_trx * 1500
    }
```

### Phase 4: ìë™í™” ì‹œìŠ¤í…œ êµ¬í˜„ (1ì¼)

#### 4.1 ìë™ ì •ì‚° ìŠ¤ì¼€ì¤„ëŸ¬
```python
# app/services/schedulers/energy_settlement_scheduler.py
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class EnergySettlementScheduler:
    def __init__(self):
        self.scheduler = AsyncIOScheduler()
        
    def start(self):
        """ìŠ¤ì¼€ì¤„ëŸ¬ ì‹œì‘"""
        # ì¼ì¼ ì •ì‚° (ë§¤ì¼ ìì •)
        self.scheduler.add_job(
            self.daily_settlement,
            'cron',
            hour=0,
            minute=0,
            id='daily_energy_settlement'
        )
        
        # ì£¼ê°„ ì •ì‚° (ë§¤ì£¼ ì›”ìš”ì¼)
        self.scheduler.add_job(
            self.weekly_settlement,
            'cron',
            day_of_week='mon',
            hour=0,
            minute=0,
            id='weekly_energy_settlement'
        )
        
        # ì›”ê°„ ì •ì‚° (ë§¤ì›” 1ì¼)
        self.scheduler.add_job(
            self.monthly_settlement,
            'cron',
            day=1,
            hour=0,
            minute=0,
            id='monthly_energy_settlement'
        )
        
        # ì—ë„ˆì§€ í’€ ëª¨ë‹ˆí„°ë§ (10ë¶„ë§ˆë‹¤)
        self.scheduler.add_job(
            self.monitor_energy_pool,
            'interval',
            minutes=10,
            id='monitor_energy_pool'
        )
        
        self.scheduler.start()
        logger.info("ì—ë„ˆì§€ ì •ì‚° ìŠ¤ì¼€ì¤„ëŸ¬ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤")
        
    async def daily_settlement(self):
        """ì¼ì¼ ì •ì‚° ì²˜ë¦¬"""
        logger.info("ì¼ì¼ ì—ë„ˆì§€ ì •ì‚° ì‹œì‘")
        
        with get_db() as db:
            service = EnergyRentalService(db)
            
            # ëª¨ë“  í™œì„± íŒŒíŠ¸ë„ˆ ì¡°íšŒ
            active_partners = db.query(Partner).join(
                EnergyRentalPlan
            ).filter(
                EnergyRentalPlan.is_active == True
            ).all()
            
            for partner in active_partners:
                try:
                    settlement = await service.process_settlement(
                        partner.id, 
                        "daily"
                    )
                    if settlement:
                        logger.info(f"íŒŒíŠ¸ë„ˆ {partner.id} ì¼ì¼ ì •ì‚° ì™„ë£Œ: {settlement.final_cost}")
                except Exception as e:
                    logger.error(f"íŒŒíŠ¸ë„ˆ {partner.id} ì •ì‚° ì‹¤íŒ¨: {str(e)}")
                    
    async def monitor_energy_pool(self):
        """ì—ë„ˆì§€ í’€ ëª¨ë‹ˆí„°ë§"""
        with get_db() as db:
            # í˜„ì¬ ì—ë„ˆì§€ ì‚¬ìš©ë¥  í™•ì¸
            total_capacity = db.query(
                func.sum(EnergyPool.staked_amount)
            ).scalar() or 0
            
            total_capacity *= 1500  # TRX to Energy
            
            today_usage = db.query(
                func.sum(EnergyUsageRecord.energy_used)
            ).filter(
                EnergyUsageRecord.created_at >= datetime.utcnow().date()
            ).scalar() or 0
            
            utilization_rate = (today_usage / total_capacity * 100) if total_capacity > 0 else 0
            
            # ì„ê³„ê°’ ì•Œë¦¼
            if utilization_rate > 80:
                await send_alert(
                    "ENERGY_POOL_WARNING",
                    f"ì—ë„ˆì§€ í’€ ì‚¬ìš©ë¥ ì´ {utilization_rate:.1f}%ì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤"
                )
            elif utilization_rate > 90:
                await send_alert(
                    "ENERGY_POOL_CRITICAL",
                    f"ì—ë„ˆì§€ í’€ì´ ê±°ì˜ ì†Œì§„ë˜ì—ˆìŠµë‹ˆë‹¤ ({utilization_rate:.1f}%)"
                )
```

#### 4.2 ê°€ê²© ìµœì í™” ì—”ì§„
```python
# app/services/energy_price_optimizer.py
import numpy as np
from datetime import datetime, timedelta
from typing import Dict, List

class EnergyPriceOptimizer:
    def __init__(self, db):
        self.db = db
        
    async def optimize_pricing(self) -> Dict:
        """AI ê¸°ë°˜ ê°€ê²© ìµœì í™”"""
        # ê³¼ê±° ë°ì´í„° ìˆ˜ì§‘
        historical_data = self._collect_historical_data()
        
        # ìˆ˜ìš” ì˜ˆì¸¡
        demand_forecast = self._forecast_demand(historical_data)
        
        # ê²½ìŸì‚¬ ê°€ê²© ë¶„ì„
        market_prices = await self._analyze_market_prices()
        
        # ìµœì  ê°€ê²© ê³„ì‚°
        optimal_prices = self._calculate_optimal_prices(
            demand_forecast,
            market_prices
        )
        
        return optimal_prices
        
    def _forecast_demand(self, historical_data: List) -> Dict:
        """ìˆ˜ìš” ì˜ˆì¸¡ (ê°„ë‹¨í•œ ì´ë™í‰ê· )"""
        # ì‹¤ì œë¡œëŠ” ë” ë³µì¡í•œ ML ëª¨ë¸ ì‚¬ìš©
        recent_usage = [d['usage'] for d in historical_data[-30:]]
        avg_usage = np.mean(recent_usage)
        trend = np.polyfit(range(len(recent_usage)), recent_usage, 1)[0]
        
        return {
            "expected_daily_usage": avg_usage,
            "growth_rate": trend,
            "peak_hours": [18, 19, 20, 21],
            "confidence": 0.85
        }
        
    def _calculate_optimal_prices(
        self, 
        demand_forecast: Dict,
        market_prices: Dict
    ) -> Dict:
        """ìµœì  ê°€ê²© ê³„ì‚°"""
        base_price = market_prices['average'] * 0.8  # ì‹œì¥ê°€ ëŒ€ë¹„ 20% í• ì¸
        
        # ìˆ˜ìš” íƒ„ë ¥ì„± ê³ ë ¤
        if demand_forecast['growth_rate'] > 0:
            # ìˆ˜ìš” ì¦ê°€ ì‹œ ê°€ê²© ìƒí–¥
            base_price *= 1.05
        
        # ì‹œê°„ëŒ€ë³„ ê°€ê²©
        peak_multiplier = 1.2 if datetime.utcnow().hour in demand_forecast['peak_hours'] else 1.0
        
        return {
            "base_price": base_price,
            "peak_price": base_price * peak_multiplier,
            "volume_discounts": {
                1000000: 0.05,    # 100ë§Œ ì—ë„ˆì§€ ì´ìƒ 5% í• ì¸
                10000000: 0.10,   # 1000ë§Œ ì—ë„ˆì§€ ì´ìƒ 10% í• ì¸
                100000000: 0.15   # 1ì–µ ì—ë„ˆì§€ ì´ìƒ 15% í• ì¸
            }
        }
```

## ğŸ“Š êµ¬í˜„ ì™„ë£Œ ì‹œ ì˜ˆìƒ íš¨ê³¼

### ìˆ˜ìµ ì‹œë®¬ë ˆì´ì…˜
```
íŒŒíŠ¸ë„ˆ 10ê°œ ê¸°ì¤€ (ì¼ì¼ 1,000ê±´ ì¶œê¸ˆ):
- ì¼ì¼ ì—ë„ˆì§€ ì‚¬ìš©: 3,200ë§Œ
- ì¼ì¼ ìˆ˜ìµ: 2,560 TRX ($307)
- ì›” ìˆœìˆ˜ìµ: 68,910 TRX ($8,269)
- ì—°ê°„ ìˆœìˆ˜ìµ: $99,228

íŒŒíŠ¸ë„ˆ 50ê°œ í™•ë³´ ì‹œ:
- ì›” ìˆœìˆ˜ìµ: $41,345
- ì—°ê°„ ìˆœìˆ˜ìµ: $496,140
```

## âœ… ê²€ì¦ í¬ì¸íŠ¸

- [ ] ë Œíƒˆ í”Œëœì´ ì •ìƒì ìœ¼ë¡œ ìƒì„±ë˜ëŠ”ê°€?
- [ ] ì—ë„ˆì§€ ì‚¬ìš© ì‹œ ì‹¤ì‹œê°„ ê³¼ê¸ˆì´ ë˜ëŠ”ê°€?
- [ ] êµ¬ë… í”Œëœ í• ë‹¹ëŸ‰ì´ ì •í™•íˆ ê´€ë¦¬ë˜ëŠ”ê°€?
- [ ] ë³¼ë¥¨ í• ì¸ì´ ìë™ ì ìš©ë˜ëŠ”ê°€?
- [ ] ì •ì‚°ì´ ìŠ¤ì¼€ì¤„ëŒ€ë¡œ ì‹¤í–‰ë˜ëŠ”ê°€?
- [ ] ë¯¸ê²°ì œ ì•Œë¦¼ì´ ë°œì†¡ë˜ëŠ”ê°€?
- [ ] ì—ë„ˆì§€ ë¶€ì¡± ì‹œ ì•Œë¦¼ì´ ì‘ë™í•˜ëŠ”ê°€?

## ğŸ‰ ê¸°ëŒ€ íš¨ê³¼

1. **íŒŒíŠ¸ë„ˆì‚¬ ì§„ì…ì¥ë²½ ì œê±°**: ì´ˆê¸° íˆ¬ì ì—†ì´ ì„œë¹„ìŠ¤ ì‹œì‘
2. **ì•ˆì •ì  ìˆ˜ìµì›**: ë³¸ì‚¬ëŠ” ë†’ì€ ìˆ˜ìµë¥  í™•ë³´
3. **ê·œëª¨ì˜ ê²½ì œ**: ëŒ€ëŸ‰ ìŠ¤í…Œì´í‚¹ìœ¼ë¡œ ì›ê°€ ì ˆê°
4. **ìë™í™”**: ê³¼ê¸ˆ/ì •ì‚° ì™„ì „ ìë™í™”
5. **í™•ì¥ì„±**: íŒŒíŠ¸ë„ˆ ì¦ê°€ì— ë”°ë¥¸ ì„ í˜•ì  ìˆ˜ìµ ì¦ê°€

ì´ ì‹œìŠ¤í…œì„ í†µí•´ ë³¸ì‚¬ì™€ íŒŒíŠ¸ë„ˆì‚¬ ëª¨ë‘ Win-Winí•˜ëŠ” í˜ì‹ ì ì¸ ë¹„ì¦ˆë‹ˆìŠ¤ ëª¨ë¸ì„ êµ¬ì¶•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!