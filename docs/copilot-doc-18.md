# Copilot ë¬¸ì„œ #18: íŒŒíŠ¸ë„ˆ ì˜¨ë³´ë”© ìë™í™” ì‹œìŠ¤í…œ

## ëª©í‘œ
ìƒˆë¡œìš´ íŒŒíŠ¸ë„ˆì‚¬ê°€ DantaroWallet í”Œë«í¼ì— íš¨ìœ¨ì ìœ¼ë¡œ ì˜¨ë³´ë”©ë  ìˆ˜ ìˆë„ë¡ ì™„ì „ ìë™í™”ëœ ì˜¨ë³´ë”© ì‹œìŠ¤í…œì„ êµ¬í˜„í•©ë‹ˆë‹¤. API í‚¤ ë°œê¸‰ë¶€í„° ì´ˆê¸° ì„¤ì •, í…ŒìŠ¤íŠ¸ í™˜ê²½ êµ¬ì¶•ê¹Œì§€ ì›í´ë¦­ìœ¼ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤.

## ì „ì œ ì¡°ê±´
- Copilot ë¬¸ì„œ #15-17ì´ ì™„ë£Œë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.
- íŒŒíŠ¸ë„ˆì‚¬ ê´€ë¦¬ ì‹œìŠ¤í…œì´ êµ¬í˜„ë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.
- ìŠˆí¼ ì–´ë“œë¯¼ ëŒ€ì‹œë³´ë“œê°€ êµ¬ì¶•ë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.

## ğŸ¯ ì˜¨ë³´ë”© ìë™í™” ì‹œìŠ¤í…œ êµ¬ì¡°

### ğŸ“‹ ì˜¨ë³´ë”© í”„ë¡œì„¸ìŠ¤ í”Œë¡œìš°
```
íŒŒíŠ¸ë„ˆ ì˜¨ë³´ë”© ìë™í™”
â”œâ”€â”€ 1ï¸âƒ£ íŒŒíŠ¸ë„ˆ ë“±ë¡ ë‹¨ê³„
â”‚   â”œâ”€â”€ ê¸°ë³¸ ì •ë³´ ì…ë ¥ (íšŒì‚¬ëª…, ë„ë©”ì¸, ì—°ë½ì²˜)
â”‚   â”œâ”€â”€ ê³„ì•½ ì¡°ê±´ ì„¤ì • (ìˆ˜ìˆ˜ë£Œìœ¨, ì„œë¹„ìŠ¤ ë ˆë²¨)
â”‚   â”œâ”€â”€ ë¸Œëœë”© ì •ë³´ ìˆ˜ì§‘ (ë¡œê³ , ìƒ‰ìƒ, í…Œë§ˆ)
â”‚   â””â”€â”€ ë²•ì  ë™ì˜ ë° ì„œëª…
â”œâ”€â”€ 2ï¸âƒ£ ê¸°ìˆ  ì„¤ì • ë‹¨ê³„
â”‚   â”œâ”€â”€ API í‚¤/ì‹œí¬ë¦¿ ìë™ ìƒì„±
â”‚   â”œâ”€â”€ ì›¹í›… URL ì„¤ì • ë° ê²€ì¦
â”‚   â”œâ”€â”€ ë„ë©”ì¸ í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ë“±ë¡
â”‚   â””â”€â”€ SSL ì¸ì¦ì„œ ì„¤ì • ì§€ì›
â”œâ”€â”€ 3ï¸âƒ£ ë¦¬ì†ŒìŠ¤ í• ë‹¹ ë‹¨ê³„
â”‚   â”œâ”€â”€ ì´ˆê¸° ì—ë„ˆì§€ í’€ í• ë‹¹
â”‚   â”œâ”€â”€ ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ìƒì„±
â”‚   â”œâ”€â”€ í…ŒìŠ¤íŠ¸ í™˜ê²½ êµ¬ì¶•
â”‚   â””â”€â”€ ëª¨ë‹ˆí„°ë§ ì„¤ì • ì´ˆê¸°í™”
â”œâ”€â”€ 4ï¸âƒ£ í…œí”Œë¦¿ ë°°í¬ ë‹¨ê³„
â”‚   â”œâ”€â”€ ì»¤ìŠ¤í„°ë§ˆì´ì§•ëœ ê´€ë¦¬ì ëŒ€ì‹œë³´ë“œ ìƒì„±
â”‚   â”œâ”€â”€ ì‚¬ìš©ì UI í…œí”Œë¦¿ ë°°í¬
â”‚   â”œâ”€â”€ API ë¬¸ì„œ ê°œì¸í™”
â”‚   â””â”€â”€ ì´ˆê¸° í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„±
â””â”€â”€ 5ï¸âƒ£ ê²€ì¦ ë° í™œì„±í™”
    â”œâ”€â”€ API ì—°ë™ í…ŒìŠ¤íŠ¸ ìë™ ì‹¤í–‰
    â”œâ”€â”€ ì›¹í›… í…ŒìŠ¤íŠ¸ ë° ê²€ì¦
    â”œâ”€â”€ ë³´ì•ˆ ì„¤ì • ê²€í† 
    â””â”€â”€ ë¼ì´ë¸Œ í™˜ê²½ í™œì„±í™”
```

## ğŸ› ï¸ êµ¬í˜„ ë‹¨ê³„

### Phase 1: ì˜¨ë³´ë”© ì›Œí¬í”Œë¡œìš° ì—”ì§„ (2ì¼)

#### 1.1 ì˜¨ë³´ë”© ìƒíƒœ ê´€ë¦¬ ëª¨ë¸
```python
# app/models/onboarding.py
"""íŒŒíŠ¸ë„ˆ ì˜¨ë³´ë”© í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬"""
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Text, Enum
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from app.models.base import Base
import enum

class OnboardingStatus(enum.Enum):
    """ì˜¨ë³´ë”© ìƒíƒœ"""
    PENDING = "pending"
    INFO_COLLECTION = "info_collection"
    TECHNICAL_SETUP = "technical_setup"
    RESOURCE_ALLOCATION = "resource_allocation"
    TEMPLATE_DEPLOYMENT = "template_deployment"
    TESTING = "testing"
    COMPLETED = "completed"
    FAILED = "failed"

class OnboardingProcess(Base):
    """ì˜¨ë³´ë”© í”„ë¡œì„¸ìŠ¤ í…Œì´ë¸”"""
    __tablename__ = "onboarding_processes"
    
    id = Column(Integer, primary_key=True, index=True)
    partner_id = Column(Integer, nullable=False, comment="íŒŒíŠ¸ë„ˆì‚¬ ID")
    status = Column(Enum(OnboardingStatus), default=OnboardingStatus.PENDING)
    current_step = Column(Integer, default=1, comment="í˜„ì¬ ë‹¨ê³„")
    total_steps = Column(Integer, default=5, comment="ì´ ë‹¨ê³„ ìˆ˜")
    progress_percentage = Column(Integer, default=0, comment="ì§„í–‰ë¥ ")
    
    # ë‹¨ê³„ë³„ ì™„ë£Œ ìƒíƒœ
    info_completed = Column(Boolean, default=False)
    technical_completed = Column(Boolean, default=False)
    resource_completed = Column(Boolean, default=False)
    template_completed = Column(Boolean, default=False)
    testing_completed = Column(Boolean, default=False)
    
    # ë©”íƒ€ë°ì´í„°
    started_at = Column(DateTime(timezone=True), server_default=func.now())
    completed_at = Column(DateTime(timezone=True))
    error_message = Column(Text, comment="ì˜¤ë¥˜ ë©”ì‹œì§€")
    configuration = Column(Text, comment="ì˜¨ë³´ë”© ì„¤ì • (JSON)")
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

class OnboardingStep(Base):
    """ì˜¨ë³´ë”© ë‹¨ê³„ë³„ ìƒì„¸ ì •ë³´"""
    __tablename__ = "onboarding_steps"
    
    id = Column(Integer, primary_key=True, index=True)
    process_id = Column(Integer, nullable=False, comment="ì˜¨ë³´ë”© í”„ë¡œì„¸ìŠ¤ ID")
    step_number = Column(Integer, nullable=False, comment="ë‹¨ê³„ ë²ˆí˜¸")
    step_name = Column(String(100), nullable=False, comment="ë‹¨ê³„ëª…")
    status = Column(String(20), default="pending", comment="ë‹¨ê³„ ìƒíƒœ")
    started_at = Column(DateTime(timezone=True))
    completed_at = Column(DateTime(timezone=True))
    error_details = Column(Text, comment="ì˜¤ë¥˜ ìƒì„¸")
    result_data = Column(Text, comment="ê²°ê³¼ ë°ì´í„° (JSON)")
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
```

#### 1.2 ì˜¨ë³´ë”© ì›Œí¬í”Œë¡œìš° ì„œë¹„ìŠ¤
```python
# app/services/onboarding/workflow_service.py
"""ì˜¨ë³´ë”© ì›Œí¬í”Œë¡œìš° ê´€ë¦¬ ì„œë¹„ìŠ¤"""
from typing import Dict, Any, Optional
from sqlalchemy.orm import Session
from app.models.onboarding import OnboardingProcess, OnboardingStep, OnboardingStatus
from app.models.partner import Partner
from app.core.logging import get_logger
import json
import asyncio

logger = get_logger(__name__)

class OnboardingWorkflowService:
    """ì˜¨ë³´ë”© ì›Œí¬í”Œë¡œìš° ê´€ë¦¬"""
    
    def __init__(self, db: Session):
        self.db = db
        self.steps = [
            {"number": 1, "name": "Information Collection", "handler": self._handle_info_collection},
            {"number": 2, "name": "Technical Setup", "handler": self._handle_technical_setup},
            {"number": 3, "name": "Resource Allocation", "handler": self._handle_resource_allocation},
            {"number": 4, "name": "Template Deployment", "handler": self._handle_template_deployment},
            {"number": 5, "name": "Testing & Verification", "handler": self._handle_testing}
        ]
    
    async def start_onboarding(self, partner_data: Dict[str, Any]) -> OnboardingProcess:
        """ì˜¨ë³´ë”© í”„ë¡œì„¸ìŠ¤ ì‹œì‘"""
        try:
            # íŒŒíŠ¸ë„ˆ ìƒì„±
            partner = Partner(**partner_data)
            self.db.add(partner)
            self.db.commit()
            self.db.refresh(partner)
            
            # ì˜¨ë³´ë”© í”„ë¡œì„¸ìŠ¤ ìƒì„±
            process = OnboardingProcess(
                partner_id=partner.id,
                configuration=json.dumps(partner_data)
            )
            self.db.add(process)
            self.db.commit()
            self.db.refresh(process)
            
            # ë‹¨ê³„ë³„ ë ˆì½”ë“œ ìƒì„±
            for step in self.steps:
                step_record = OnboardingStep(
                    process_id=process.id,
                    step_number=step["number"],
                    step_name=step["name"]
                )
                self.db.add(step_record)
            
            self.db.commit()
            
            logger.info(f"ì˜¨ë³´ë”© í”„ë¡œì„¸ìŠ¤ ì‹œì‘: Partner ID {partner.id}")
            
            # ì²« ë²ˆì§¸ ë‹¨ê³„ ìë™ ì‹¤í–‰
            await self._execute_next_step(process)
            
            return process
            
        except Exception as e:
            logger.error(f"ì˜¨ë³´ë”© ì‹œì‘ ì‹¤íŒ¨: {e}")
            raise
    
    async def _execute_next_step(self, process: OnboardingProcess):
        """ë‹¤ìŒ ë‹¨ê³„ ì‹¤í–‰"""
        try:
            current_step = self.steps[process.current_step - 1]
            step_record = self.db.query(OnboardingStep).filter(
                OnboardingStep.process_id == process.id,
                OnboardingStep.step_number == process.current_step
            ).first()
            
            if not step_record:
                raise Exception(f"ë‹¨ê³„ ë ˆì½”ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: {process.current_step}")
            
            # ë‹¨ê³„ ì‹œì‘
            step_record.status = "running"
            step_record.started_at = func.now()
            process.status = OnboardingStatus.INFO_COLLECTION if process.current_step == 1 else process.status
            self.db.commit()
            
            logger.info(f"ë‹¨ê³„ {process.current_step} ì‹¤í–‰ ì¤‘: {current_step['name']}")
            
            # ë‹¨ê³„ë³„ í•¸ë“¤ëŸ¬ ì‹¤í–‰
            result = await current_step["handler"](process)
            
            # ë‹¨ê³„ ì™„ë£Œ ì²˜ë¦¬
            step_record.status = "completed"
            step_record.completed_at = func.now()
            step_record.result_data = json.dumps(result)
            
            # ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
            process.progress_percentage = int((process.current_step / len(self.steps)) * 100)
            
            # ë‹¨ê³„ë³„ ì™„ë£Œ í”Œë˜ê·¸ ì„¤ì •
            if process.current_step == 1:
                process.info_completed = True
                process.status = OnboardingStatus.TECHNICAL_SETUP
            elif process.current_step == 2:
                process.technical_completed = True
                process.status = OnboardingStatus.RESOURCE_ALLOCATION
            elif process.current_step == 3:
                process.resource_completed = True
                process.status = OnboardingStatus.TEMPLATE_DEPLOYMENT
            elif process.current_step == 4:
                process.template_completed = True
                process.status = OnboardingStatus.TESTING
            elif process.current_step == 5:
                process.testing_completed = True
                process.status = OnboardingStatus.COMPLETED
                process.completed_at = func.now()
            
            self.db.commit()
            
            # ë‹¤ìŒ ë‹¨ê³„ë¡œ ì§„í–‰
            if process.current_step < len(self.steps):
                process.current_step += 1
                self.db.commit()
                
                # ë‹¤ìŒ ë‹¨ê³„ ìë™ ì‹¤í–‰ (ë¹„ë™ê¸°)
                asyncio.create_task(self._execute_next_step(process))
            else:
                logger.info(f"ì˜¨ë³´ë”© ì™„ë£Œ: Partner ID {process.partner_id}")
                
        except Exception as e:
            logger.error(f"ë‹¨ê³„ ì‹¤í–‰ ì‹¤íŒ¨: {e}")
            step_record.status = "failed"
            step_record.error_details = str(e)
            process.status = OnboardingStatus.FAILED
            process.error_message = str(e)
            self.db.commit()
            raise
    
    async def _handle_info_collection(self, process: OnboardingProcess) -> Dict[str, Any]:
        """1ë‹¨ê³„: ì •ë³´ ìˆ˜ì§‘ ì²˜ë¦¬"""
        # íŒŒíŠ¸ë„ˆ ì •ë³´ ê²€ì¦ ë° ë³´ì™„
        partner = self.db.query(Partner).filter(Partner.id == process.partner_id).first()
        
        result = {
            "partner_validated": True,
            "domain_verified": await self._verify_domain(partner.domain),
            "contact_verified": await self._verify_contact(partner),
            "legal_docs_processed": True
        }
        
        return result
    
    async def _handle_technical_setup(self, process: OnboardingProcess) -> Dict[str, Any]:
        """2ë‹¨ê³„: ê¸°ìˆ  ì„¤ì • ì²˜ë¦¬"""
        from app.services.partner.api_service import PartnerAPIService
        
        api_service = PartnerAPIService(self.db)
        partner = self.db.query(Partner).filter(Partner.id == process.partner_id).first()
        
        # API í‚¤/ì‹œí¬ë¦¿ ìƒì„±
        api_credentials = await api_service.generate_api_credentials(partner.id)
        
        # ì›¹í›… URL ê²€ì¦
        webhook_verified = await self._verify_webhook(partner.webhook_url) if partner.webhook_url else False
        
        result = {
            "api_key_generated": True,
            "api_secret_generated": True,
            "webhook_verified": webhook_verified,
            "ssl_configured": True,
            "domain_whitelisted": True
        }
        
        return result
    
    async def _handle_resource_allocation(self, process: OnboardingProcess) -> Dict[str, Any]:
        """3ë‹¨ê³„: ë¦¬ì†ŒìŠ¤ í• ë‹¹ ì²˜ë¦¬"""
        from app.services.energy.pool_service import EnergyPoolService
        
        energy_service = EnergyPoolService(self.db)
        partner = self.db.query(Partner).filter(Partner.id == process.partner_id).first()
        
        # ì´ˆê¸° ì—ë„ˆì§€ í’€ í• ë‹¹
        initial_energy = 10000  # ì´ˆê¸° í• ë‹¹ëŸ‰
        energy_allocation = await energy_service.allocate_initial_energy(partner.id, initial_energy)
        
        # ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ìƒì„± (íŒŒí‹°ì…”ë‹)
        schema_created = await self._create_partner_schema(partner.id)
        
        # ëª¨ë‹ˆí„°ë§ ì„¤ì •
        monitoring_setup = await self._setup_monitoring(partner.id)
        
        result = {
            "energy_allocated": initial_energy,
            "database_schema_created": schema_created,
            "monitoring_configured": monitoring_setup,
            "test_environment_ready": True
        }
        
        return result
    
    async def _handle_template_deployment(self, process: OnboardingProcess) -> Dict[str, Any]:
        """4ë‹¨ê³„: í…œí”Œë¦¿ ë°°í¬ ì²˜ë¦¬"""
        from app.services.template.deployment_service import TemplateDeploymentService
        
        template_service = TemplateDeploymentService(self.db)
        partner = self.db.query(Partner).filter(Partner.id == process.partner_id).first()
        
        # ì»¤ìŠ¤í„°ë§ˆì´ì§•ëœ ëŒ€ì‹œë³´ë“œ ìƒì„±
        dashboard_deployed = await template_service.deploy_admin_dashboard(partner.id)
        
        # ì‚¬ìš©ì UI í…œí”Œë¦¿ ë°°í¬
        ui_deployed = await template_service.deploy_user_ui(partner.id)
        
        # API ë¬¸ì„œ ê°œì¸í™”
        docs_personalized = await template_service.personalize_api_docs(partner.id)
        
        # í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„±
        test_data_created = await self._create_test_data(partner.id)
        
        result = {
            "admin_dashboard_deployed": dashboard_deployed,
            "user_ui_deployed": ui_deployed,
            "api_docs_personalized": docs_personalized,
            "test_data_created": test_data_created
        }
        
        return result
    
    async def _handle_testing(self, process: OnboardingProcess) -> Dict[str, Any]:
        """5ë‹¨ê³„: í…ŒìŠ¤íŒ… ë° ê²€ì¦ ì²˜ë¦¬"""
        from app.services.testing.integration_service import IntegrationTestService
        
        test_service = IntegrationTestService(self.db)
        partner = self.db.query(Partner).filter(Partner.id == process.partner_id).first()
        
        # API ì—°ë™ í…ŒìŠ¤íŠ¸
        api_tests = await test_service.run_api_integration_tests(partner.id)
        
        # ì›¹í›… í…ŒìŠ¤íŠ¸
        webhook_tests = await test_service.run_webhook_tests(partner.id)
        
        # ë³´ì•ˆ ê²€ì¦
        security_check = await self._run_security_verification(partner.id)
        
        # ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
        performance_test = await self._run_performance_tests(partner.id)
        
        all_tests_passed = all([
            api_tests["passed"],
            webhook_tests["passed"],
            security_check["passed"],
            performance_test["passed"]
        ])
        
        if all_tests_passed:
            # ë¼ì´ë¸Œ í™˜ê²½ í™œì„±í™”
            await self._activate_live_environment(partner.id)
        
        result = {
            "api_tests_passed": api_tests["passed"],
            "webhook_tests_passed": webhook_tests["passed"],
            "security_verified": security_check["passed"],
            "performance_verified": performance_test["passed"],
            "live_environment_activated": all_tests_passed
        }
        
        return result
    
    # í—¬í¼ ë©”ì„œë“œë“¤
    async def _verify_domain(self, domain: str) -> bool:
        """ë„ë©”ì¸ ê²€ì¦"""
        # DNS ê²€ì¦, SSL í™•ì¸ ë“±
        return True
    
    async def _verify_contact(self, partner: Partner) -> bool:
        """ì—°ë½ì²˜ ê²€ì¦"""
        # ì´ë©”ì¼ ë°œì†¡, ì „í™” í™•ì¸ ë“±
        return True
    
    async def _verify_webhook(self, webhook_url: str) -> bool:
        """ì›¹í›… URL ê²€ì¦"""
        # í…ŒìŠ¤íŠ¸ ìš”ì²­ ë°œì†¡
        return True
    
    async def _create_partner_schema(self, partner_id: int) -> bool:
        """íŒŒíŠ¸ë„ˆë³„ DB ìŠ¤í‚¤ë§ˆ ìƒì„±"""
        # íŒŒí‹°ì…”ë‹ ë˜ëŠ” ìŠ¤í‚¤ë§ˆ ë¶„ë¦¬
        return True
    
    async def _setup_monitoring(self, partner_id: int) -> bool:
        """ëª¨ë‹ˆí„°ë§ ì„¤ì •"""
        # ë¡œê·¸ ìˆ˜ì§‘, ë©”íŠ¸ë¦­ ì„¤ì • ë“±
        return True
    
    async def _create_test_data(self, partner_id: int) -> bool:
        """í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„±"""
        # ìƒ˜í”Œ ì‚¬ìš©ì, ê±°ë˜ ë“± ìƒì„±
        return True
    
    async def _run_security_verification(self, partner_id: int) -> Dict[str, Any]:
        """ë³´ì•ˆ ê²€ì¦"""
        return {"passed": True, "issues": []}
    
    async def _run_performance_tests(self, partner_id: int) -> Dict[str, Any]:
        """ì„±ëŠ¥ í…ŒìŠ¤íŠ¸"""
        return {"passed": True, "response_time": "< 200ms"}
    
    async def _activate_live_environment(self, partner_id: int):
        """ë¼ì´ë¸Œ í™˜ê²½ í™œì„±í™”"""
        partner = self.db.query(Partner).filter(Partner.id == partner_id).first()
        partner.is_active = True
        self.db.commit()
```

### Phase 2: ì˜¨ë³´ë”© API ì—”ë“œí¬ì¸íŠ¸ (1ì¼)

#### 2.1 ì˜¨ë³´ë”© API ì—”ë“œí¬ì¸íŠ¸
```python
# app/api/v1/endpoints/onboarding.py
"""ì˜¨ë³´ë”© ê´€ë ¨ API ì—”ë“œí¬ì¸íŠ¸"""
from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from sqlalchemy.orm import Session
from typing import List
from app.api.deps import get_db, get_current_superuser
from app.services.onboarding.workflow_service import OnboardingWorkflowService
from app.schemas.onboarding import (
    OnboardingProcessCreate,
    OnboardingProcessResponse,
    OnboardingStepResponse
)

router = APIRouter()

@router.post("/start", response_model=OnboardingProcessResponse)
async def start_partner_onboarding(
    partner_data: OnboardingProcessCreate,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db),
    current_user = Depends(get_current_superuser)
):
    """íŒŒíŠ¸ë„ˆ ì˜¨ë³´ë”© í”„ë¡œì„¸ìŠ¤ ì‹œì‘"""
    try:
        workflow_service = OnboardingWorkflowService(db)
        process = await workflow_service.start_onboarding(partner_data.dict())
        
        return OnboardingProcessResponse.from_orm(process)
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"ì˜¨ë³´ë”© ì‹œì‘ ì‹¤íŒ¨: {str(e)}")

@router.get("/{process_id}", response_model=OnboardingProcessResponse)
async def get_onboarding_status(
    process_id: int,
    db: Session = Depends(get_db),
    current_user = Depends(get_current_superuser)
):
    """ì˜¨ë³´ë”© í”„ë¡œì„¸ìŠ¤ ìƒíƒœ ì¡°íšŒ"""
    process = db.query(OnboardingProcess).filter(
        OnboardingProcess.id == process_id
    ).first()
    
    if not process:
        raise HTTPException(status_code=404, detail="ì˜¨ë³´ë”© í”„ë¡œì„¸ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
    
    return OnboardingProcessResponse.from_orm(process)

@router.get("/{process_id}/steps", response_model=List[OnboardingStepResponse])
async def get_onboarding_steps(
    process_id: int,
    db: Session = Depends(get_db),
    current_user = Depends(get_current_superuser)
):
    """ì˜¨ë³´ë”© ë‹¨ê³„ë³„ ìƒì„¸ ì •ë³´ ì¡°íšŒ"""
    steps = db.query(OnboardingStep).filter(
        OnboardingStep.process_id == process_id
    ).order_by(OnboardingStep.step_number).all()
    
    return [OnboardingStepResponse.from_orm(step) for step in steps]

@router.post("/{process_id}/retry")
async def retry_failed_step(
    process_id: int,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db),
    current_user = Depends(get_current_superuser)
):
    """ì‹¤íŒ¨í•œ ë‹¨ê³„ ì¬ì‹œë„"""
    process = db.query(OnboardingProcess).filter(
        OnboardingProcess.id == process_id
    ).first()
    
    if not process:
        raise HTTPException(status_code=404, detail="ì˜¨ë³´ë”© í”„ë¡œì„¸ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
    
    if process.status != OnboardingStatus.FAILED:
        raise HTTPException(status_code=400, detail="ì¬ì‹œë„í•  ìˆ˜ ì—†ëŠ” ìƒíƒœì…ë‹ˆë‹¤")
    
    # ì‹¤íŒ¨í•œ ë‹¨ê³„ë¶€í„° ì¬ì‹œì‘
    workflow_service = OnboardingWorkflowService(db)
    background_tasks.add_task(workflow_service._execute_next_step, process)
    
    return {"message": "ì¬ì‹œë„ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤"}

@router.get("/", response_model=List[OnboardingProcessResponse])
async def list_onboarding_processes(
    skip: int = 0,
    limit: int = 100,
    status: Optional[OnboardingStatus] = None,
    db: Session = Depends(get_db),
    current_user = Depends(get_current_superuser)
):
    """ì˜¨ë³´ë”© í”„ë¡œì„¸ìŠ¤ ëª©ë¡ ì¡°íšŒ"""
    query = db.query(OnboardingProcess)
    
    if status:
        query = query.filter(OnboardingProcess.status == status)
    
    processes = query.offset(skip).limit(limit).all()
    
    return [OnboardingProcessResponse.from_orm(process) for process in processes]
```

### Phase 3: ì˜¨ë³´ë”© ìŠ¤í‚¤ë§ˆ ì •ì˜ (30ë¶„)

#### 3.1 ì˜¨ë³´ë”© ìŠ¤í‚¤ë§ˆ
```python
# app/schemas/onboarding.py
"""ì˜¨ë³´ë”© ê´€ë ¨ ìŠ¤í‚¤ë§ˆ"""
from pydantic import BaseModel, EmailStr
from typing import Optional, Dict, Any, List
from datetime import datetime
from app.models.onboarding import OnboardingStatus

class OnboardingProcessCreate(BaseModel):
    """ì˜¨ë³´ë”© í”„ë¡œì„¸ìŠ¤ ìƒì„± ìš”ì²­"""
    name: str
    domain: Optional[str] = None
    contact_email: EmailStr
    contact_phone: Optional[str] = None
    webhook_url: Optional[str] = None
    commission_rate: Optional[float] = 0.0
    branding_config: Optional[Dict[str, Any]] = None
    technical_config: Optional[Dict[str, Any]] = None

class OnboardingProcessResponse(BaseModel):
    """ì˜¨ë³´ë”© í”„ë¡œì„¸ìŠ¤ ì‘ë‹µ"""
    id: int
    partner_id: int
    status: OnboardingStatus
    current_step: int
    total_steps: int
    progress_percentage: int
    
    info_completed: bool
    technical_completed: bool
    resource_completed: bool
    template_completed: bool
    testing_completed: bool
    
    started_at: datetime
    completed_at: Optional[datetime]
    error_message: Optional[str]
    
    class Config:
        from_attributes = True

class OnboardingStepResponse(BaseModel):
    """ì˜¨ë³´ë”© ë‹¨ê³„ ì‘ë‹µ"""
    id: int
    process_id: int
    step_number: int
    step_name: str
    status: str
    started_at: Optional[datetime]
    completed_at: Optional[datetime]
    error_details: Optional[str]
    result_data: Optional[str]
    
    class Config:
        from_attributes = True
```

## ğŸ¯ í”„ë¡ íŠ¸ì—”ë“œ ì˜¨ë³´ë”© UI

### ëŒ€ì‹œë³´ë“œ ì˜¨ë³´ë”© ì„¹ì…˜
```typescript
// frontend/super-admin-dashboard/src/components/onboarding/OnboardingWizard.tsx
import React, { useState } from 'react';
import { Steps, Card, Form, Input, Button, Progress, Alert } from 'antd';

const OnboardingWizard: React.FC = () => {
    const [currentStep, setCurrentStep] = useState(0);
    const [form] = Form.useForm();
    const [loading, setLoading] = useState(false);
    const [processId, setProcessId] = useState<number | null>(null);

    const steps = [
        {
            title: 'ê¸°ë³¸ ì •ë³´',
            content: <BasicInfoForm form={form} />
        },
        {
            title: 'ê¸°ìˆ  ì„¤ì •',
            content: <TechnicalSetupForm form={form} />
        },
        {
            title: 'ë¸Œëœë”©',
            content: <BrandingForm form={form} />
        },
        {
            title: 'ê²€í†  ë° ì‹œì‘',
            content: <ReviewForm form={form} />
        }
    ];

    const handleNext = async () => {
        if (currentStep === steps.length - 1) {
            // ì˜¨ë³´ë”© ì‹œì‘
            await startOnboarding();
        } else {
            setCurrentStep(currentStep + 1);
        }
    };

    const startOnboarding = async () => {
        setLoading(true);
        try {
            const values = await form.validateFields();
            const response = await fetch('/api/v1/onboarding/start', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(values)
            });
            
            const result = await response.json();
            setProcessId(result.id);
            
        } catch (error) {
            console.error('ì˜¨ë³´ë”© ì‹œì‘ ì‹¤íŒ¨:', error);
        } finally {
            setLoading(false);
        }
    };

    if (processId) {
        return <OnboardingProgress processId={processId} />;
    }

    return (
        <Card title="ìƒˆ íŒŒíŠ¸ë„ˆ ì˜¨ë³´ë”©">
            <Steps current={currentStep} items={steps} />
            <div style={{ marginTop: 24 }}>
                {steps[currentStep].content}
            </div>
            <div style={{ marginTop: 24 }}>
                {currentStep > 0 && (
                    <Button onClick={() => setCurrentStep(currentStep - 1)}>
                        ì´ì „
                    </Button>
                )}
                <Button 
                    type="primary" 
                    onClick={handleNext}
                    loading={loading}
                    style={{ marginLeft: 8 }}
                >
                    {currentStep === steps.length - 1 ? 'ì˜¨ë³´ë”© ì‹œì‘' : 'ë‹¤ìŒ'}
                </Button>
            </div>
        </Card>
    );
};
```

## ğŸ“Š ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼

### ì˜¨ë³´ë”© ì§„í–‰ë¥  ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
```python
# app/services/onboarding/monitoring_service.py
"""ì˜¨ë³´ë”© ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤"""
from typing import List, Dict, Any
from sqlalchemy.orm import Session
from app.models.onboarding import OnboardingProcess, OnboardingStatus
from app.core.logging import get_logger

logger = get_logger(__name__)

class OnboardingMonitoringService:
    """ì˜¨ë³´ë”© ëª¨ë‹ˆí„°ë§"""
    
    def __init__(self, db: Session):
        self.db = db
    
    def get_onboarding_analytics(self) -> Dict[str, Any]:
        """ì˜¨ë³´ë”© ë¶„ì„ ë°ì´í„°"""
        processes = self.db.query(OnboardingProcess).all()
        
        total_count = len(processes)
        completed_count = len([p for p in processes if p.status == OnboardingStatus.COMPLETED])
        failed_count = len([p for p in processes if p.status == OnboardingStatus.FAILED])
        in_progress_count = total_count - completed_count - failed_count
        
        return {
            "total_onboardings": total_count,
            "completed": completed_count,
            "failed": failed_count,
            "in_progress": in_progress_count,
            "success_rate": (completed_count / total_count * 100) if total_count > 0 else 0,
            "average_completion_time": self._calculate_average_completion_time(processes)
        }
    
    def _calculate_average_completion_time(self, processes: List[OnboardingProcess]) -> float:
        """í‰ê·  ì™„ë£Œ ì‹œê°„ ê³„ì‚° (ì‹œê°„ ë‹¨ìœ„)"""
        completed_processes = [
            p for p in processes 
            if p.status == OnboardingStatus.COMPLETED and p.completed_at
        ]
        
        if not completed_processes:
            return 0.0
        
        total_hours = sum([
            (p.completed_at - p.started_at).total_seconds() / 3600
            for p in completed_processes
        ])
        
        return total_hours / len(completed_processes)
```

## âœ… ê²€ì¦ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸
- [ ] íŒŒíŠ¸ë„ˆ ì •ë³´ ì…ë ¥ ë° ê²€ì¦
- [ ] API í‚¤ ìë™ ìƒì„± ë° ë³´ì•ˆ
- [ ] ì›¹í›… URL ìœ íš¨ì„± ê²€ì¦
- [ ] ì—ë„ˆì§€ í’€ ìë™ í• ë‹¹
- [ ] í…œí”Œë¦¿ ìë™ ë°°í¬
- [ ] í†µí•© í…ŒìŠ¤íŠ¸ ìë™ ì‹¤í–‰
- [ ] ì‹¤ì‹œê°„ ì§„í–‰ë¥  ëª¨ë‹ˆí„°ë§
- [ ] ì˜¤ë¥˜ ì‹œ ìë™ ì¬ì‹œë„
- [ ] ì™„ë£Œ í›„ ìë™ í™œì„±í™”

### ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
- [ ] ì˜¨ë³´ë”© í”„ë¡œì„¸ìŠ¤ ì™„ë£Œ ì‹œê°„ < 10ë¶„
- [ ] ë™ì‹œ ì˜¨ë³´ë”© ì²˜ë¦¬ ì„±ëŠ¥ (5ê°œ ì´ìƒ)
- [ ] ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ëŸ‰ ìµœì í™”
- [ ] ë°ì´í„°ë² ì´ìŠ¤ ë¶€í•˜ í…ŒìŠ¤íŠ¸

### ë³´ì•ˆ ê²€ì¦
- [ ] API í‚¤ ìƒì„± ë³´ì•ˆì„±
- [ ] ë¯¼ê° ì •ë³´ ì•”í˜¸í™”
- [ ] ì ‘ê·¼ ê¶Œí•œ ê²€ì¦
- [ ] ê°ì‚¬ ë¡œê·¸ ê¸°ë¡

## ğŸ“ˆ ì˜ˆìƒ íš¨ê³¼

### ë¹„ì¦ˆë‹ˆìŠ¤ ì„íŒ©íŠ¸
- **ì˜¨ë³´ë”© ì‹œê°„ ë‹¨ì¶•**: ìˆ˜ë™ 3-5ì¼ â†’ ìë™ 10ë¶„ ë‚´
- **ì˜¤ë¥˜ ê°ì†Œ**: ìˆ˜ë™ ì„¤ì • ì˜¤ë¥˜ 90% ê°ì†Œ
- **ìš´ì˜ ë¹„ìš© ì ˆê°**: ì˜¨ë³´ë”© ë‹´ë‹¹ì ì›Œí¬ë¡œë“œ 80% ê°ì†Œ
- **íŒŒíŠ¸ë„ˆ ë§Œì¡±ë„ í–¥ìƒ**: ì¦‰ì‹œ ì‹œì‘ ê°€ëŠ¥í•œ í™˜ê²½ ì œê³µ

### ê¸°ìˆ ì  ì´ì 
- **í‘œì¤€í™”ëœ í”„ë¡œì„¸ìŠ¤**: ì¼ê´€ëœ íŒŒíŠ¸ë„ˆ í™˜ê²½ êµ¬ì¶•
- **ìë™í™”ëœ ê²€ì¦**: í’ˆì§ˆ ë³´ì¥ ë° ì˜¤ë¥˜ ë°©ì§€
- **í™•ì¥ ê°€ëŠ¥ì„±**: ëŒ€ëŸ‰ íŒŒíŠ¸ë„ˆ ì˜¨ë³´ë”© ì§€ì›
- **ëª¨ë‹ˆí„°ë§ ê°•í™”**: ì‹¤ì‹œê°„ ìƒíƒœ ì¶”ì  ë° ë¶„ì„

ì´ ì˜¨ë³´ë”© ìë™í™” ì‹œìŠ¤í…œìœ¼ë¡œ DantaroWalletì€ ì§„ì •í•œ SaaS í”Œë«í¼ìœ¼ë¡œì„œ íŒŒíŠ¸ë„ˆì‚¬ë“¤ì—ê²Œ ìµœê³ ì˜ ì˜¨ë³´ë”© ê²½í—˜ì„ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
