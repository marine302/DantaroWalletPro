# Copilot ë¬¸ì„œ #27: ì…ê¸ˆ Sweep ìë™í™” ì‹œìŠ¤í…œ

## ëª©í‘œ
ì‚¬ìš©ìì˜ ê°œë³„ ì…ê¸ˆ ì§€ê°‘ìœ¼ë¡œ ë“¤ì–´ì˜¨ USDTë¥¼ íŒŒíŠ¸ë„ˆì‚¬ì˜ ì¤‘ì•™ ì§€ê°‘(TronLink)ìœ¼ë¡œ ìë™ìœ¼ë¡œ ì´ë™(Sweep)í•˜ëŠ” ì‹œìŠ¤í…œì„ êµ¬ì¶•í•©ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ìì‚°ì„ ì¤‘ì•™ì—ì„œ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•˜ê³  ë³´ì•ˆì„ ê°•í™”í•©ë‹ˆë‹¤.

## ì „ì œ ì¡°ê±´
- Copilot ë¬¸ì„œ #24-26ì´ ì™„ë£Œë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.
- íŒŒíŠ¸ë„ˆì‚¬ TronLink ì§€ê°‘ì´ ì—°ë™ë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.
- HD Wallet í‚¤ ìƒì„± ì‹œìŠ¤í…œì´ êµ¬í˜„ë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.
- ë¸”ë¡ì²´ì¸ ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤ê°€ ì‘ë™ ì¤‘ì´ì–´ì•¼ í•©ë‹ˆë‹¤.

## ğŸ¯ Sweep ìë™í™” ì‹œìŠ¤í…œ êµ¬ì¡°

### ğŸ“Š ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜
```
ì…ê¸ˆ Sweep ìë™í™”
â”œâ”€â”€ ğŸ”‘ HD Wallet ê´€ë¦¬
â”‚   â”œâ”€â”€ ë§ˆìŠ¤í„° ì‹œë“œ ê´€ë¦¬
â”‚   â”œâ”€â”€ ì‚¬ìš©ìë³„ ì£¼ì†Œ íŒŒìƒ
â”‚   â”œâ”€â”€ ê°œì¸í‚¤ ì•ˆì „ ë³´ê´€
â”‚   â””â”€â”€ ì£¼ì†Œ í’€ ê´€ë¦¬
â”œâ”€â”€ ğŸ‘ï¸ ì…ê¸ˆ ëª¨ë‹ˆí„°ë§
â”‚   â”œâ”€â”€ ë¸”ë¡ì²´ì¸ ì‹¤ì‹œê°„ ìŠ¤ìº”
â”‚   â”œâ”€â”€ ì…ê¸ˆ íŠ¸ëœì­ì…˜ ê°ì§€
â”‚   â”œâ”€â”€ ì»¨íŒ ëŒ€ê¸° ë° ê²€ì¦
â”‚   â””â”€â”€ ì…ê¸ˆ ì•Œë¦¼ ë°œì†¡
â”œâ”€â”€ ğŸ”„ Sweep ì‹¤í–‰
â”‚   â”œâ”€â”€ Sweep ëŒ€ìƒ í•„í„°ë§
â”‚   â”œâ”€â”€ íŠ¸ëœì­ì…˜ ìƒì„±
â”‚   â”œâ”€â”€ ê°€ìŠ¤ë¹„ ê³„ì‚° ë° ìµœì í™”
â”‚   â”œâ”€â”€ ë°°ì¹˜ ì²˜ë¦¬ ì§€ì›
â”‚   â””â”€â”€ ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„
â”œâ”€â”€ ğŸ“‹ Sweep ì •ì±…
â”‚   â”œâ”€â”€ ìµœì†Œ ê¸ˆì•¡ ì„¤ì •
â”‚   â”œâ”€â”€ ì‹œê°„ ê¸°ë°˜ ìŠ¤ì¼€ì¤„
â”‚   â”œâ”€â”€ ê°€ìŠ¤ë¹„ ì„ê³„ê°’
â”‚   â”œâ”€â”€ ìš°ì„ ìˆœìœ„ ì„¤ì •
â”‚   â””â”€â”€ ê¸´ê¸‰ Sweep ì˜µì…˜
â””â”€â”€ ğŸ“Š ëª¨ë‹ˆí„°ë§ & ë¶„ì„
    â”œâ”€â”€ Sweep ìƒíƒœ ì¶”ì 
    â”œâ”€â”€ ë¹„ìš© ë¶„ì„
    â”œâ”€â”€ ì„±ê³µë¥  ëª¨ë‹ˆí„°ë§
    â””â”€â”€ ìµœì í™” ì œì•ˆ
```

## ğŸ› ï¸ êµ¬í˜„ ë‹¨ê³„

### Phase 1: HD Wallet ë° ì£¼ì†Œ ê´€ë¦¬ (1ì¼)

#### 1.1 HD Wallet ëª¨ë¸
```python
# app/models/hd_wallet.py
"""HD Wallet ê´€ë¦¬ ê´€ë ¨ ëª¨ë¸"""
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Numeric, JSON, ForeignKey, Index
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from app.models.base import Base

class HDWalletMaster(Base):
    """HD Wallet ë§ˆìŠ¤í„° ì •ë³´"""
    __tablename__ = "hd_wallet_masters"
    
    id = Column(Integer, primary_key=True, index=True)
    partner_id = Column(Integer, ForeignKey("partners.id"), nullable=False, unique=True)
    
    # ì•”í˜¸í™”ëœ ë§ˆìŠ¤í„° ì‹œë“œ
    encrypted_seed = Column(String(500), nullable=False, comment="ì•”í˜¸í™”ëœ ë§ˆìŠ¤í„° ì‹œë“œ")
    public_key = Column(String(130), nullable=False, comment="ë§ˆìŠ¤í„° ê³µê°œí‚¤")
    
    # íŒŒìƒ ì •ë³´
    derivation_path = Column(String(100), default="m/44'/195'/0'/0", comment="íŒŒìƒ ê²½ë¡œ")
    last_index = Column(Integer, default=0, comment="ë§ˆì§€ë§‰ ì‚¬ìš© ì¸ë±ìŠ¤")
    
    # ë³´ì•ˆ ì„¤ì •
    encryption_method = Column(String(50), default="AES-256-GCM", comment="ì•”í˜¸í™” ë°©ì‹")
    key_version = Column(Integer, default=1, comment="í‚¤ ë²„ì „")
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # ê´€ê³„ ì„¤ì •
    addresses = relationship("UserDepositAddress", back_populates="hd_wallet")

class UserDepositAddress(Base):
    """ì‚¬ìš©ì ì…ê¸ˆ ì£¼ì†Œ"""
    __tablename__ = "user_deposit_addresses"
    
    id = Column(Integer, primary_key=True, index=True)
    hd_wallet_id = Column(Integer, ForeignKey("hd_wallet_masters.id"), nullable=False)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    
    # ì£¼ì†Œ ì •ë³´
    address = Column(String(42), nullable=False, unique=True, index=True, comment="ì…ê¸ˆ ì£¼ì†Œ")
    derivation_index = Column(Integer, nullable=False, comment="íŒŒìƒ ì¸ë±ìŠ¤")
    encrypted_private_key = Column(String(500), nullable=False, comment="ì•”í˜¸í™”ëœ ê°œì¸í‚¤")
    
    # ìƒíƒœ ì •ë³´
    is_active = Column(Boolean, default=True, comment="í™œì„± ìƒíƒœ")
    total_received = Column(Numeric(18, 6), default=0, comment="ì´ ì…ê¸ˆì•¡")
    last_sweep_at = Column(DateTime(timezone=True), comment="ë§ˆì§€ë§‰ Sweep ì‹œê°„")
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # ê´€ê³„ ì„¤ì •
    hd_wallet = relationship("HDWalletMaster", back_populates="addresses")
    sweep_logs = relationship("SweepLog", back_populates="deposit_address")
    
    # ì¸ë±ìŠ¤
    __table_args__ = (
        Index("idx_deposit_address_user", "user_id"),
        Index("idx_deposit_address_active", "is_active"),
    )

class SweepConfiguration(Base):
    """Sweep ì„¤ì •"""
    __tablename__ = "sweep_configurations"
    
    id = Column(Integer, primary_key=True, index=True)
    partner_id = Column(Integer, ForeignKey("partners.id"), nullable=False, unique=True)
    
    # Sweep ëŒ€ìƒ ì§€ê°‘
    destination_wallet_id = Column(Integer, ForeignKey("partner_wallets.id"), nullable=False)
    
    # ê¸°ë³¸ ì„¤ì •
    is_enabled = Column(Boolean, default=True, comment="Sweep í™œì„±í™”")
    min_sweep_amount = Column(Numeric(18, 6), default=10, comment="ìµœì†Œ Sweep ê¸ˆì•¡")
    
    # ìŠ¤ì¼€ì¤„ ì„¤ì •
    sweep_interval_minutes = Column(Integer, default=60, comment="Sweep ê°„ê²© (ë¶„)")
    immediate_threshold = Column(Numeric(18, 6), default=1000, comment="ì¦‰ì‹œ Sweep ì„ê³„ê°’")
    
    # ê°€ìŠ¤ë¹„ ì„¤ì •
    max_gas_price_sun = Column(Numeric(20, 0), default=1000, comment="ìµœëŒ€ ê°€ìŠ¤ë¹„ (SUN)")
    gas_optimization_enabled = Column(Boolean, default=True, comment="ê°€ìŠ¤ë¹„ ìµœì í™”")
    
    # ë°°ì¹˜ ì„¤ì •
    batch_enabled = Column(Boolean, default=True, comment="ë°°ì¹˜ ì²˜ë¦¬ í™œì„±í™”")
    max_batch_size = Column(Integer, default=20, comment="ìµœëŒ€ ë°°ì¹˜ í¬ê¸°")
    
    # ì•Œë¦¼ ì„¤ì •
    notification_enabled = Column(Boolean, default=True, comment="ì•Œë¦¼ í™œì„±í™”")
    notification_channels = Column(JSON, comment="ì•Œë¦¼ ì±„ë„ ì„¤ì •")
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # ê´€ê³„ ì„¤ì •
    destination_wallet = relationship("PartnerWallet")

class SweepLog(Base):
    """Sweep ì‹¤í–‰ ë¡œê·¸"""
    __tablename__ = "sweep_logs"
    
    id = Column(Integer, primary_key=True, index=True)
    deposit_address_id = Column(Integer, ForeignKey("user_deposit_addresses.id"), nullable=False)
    
    # Sweep ì •ë³´
    sweep_amount = Column(Numeric(18, 6), nullable=False, comment="Sweep ê¸ˆì•¡")
    gas_used = Column(Numeric(20, 0), comment="ì‚¬ìš©ëœ ê°€ìŠ¤")
    gas_price = Column(Numeric(20, 0), comment="ê°€ìŠ¤ ê°€ê²©")
    tx_hash = Column(String(66), index=True, comment="íŠ¸ëœì­ì…˜ í•´ì‹œ")
    
    # ìƒíƒœ
    status = Column(String(20), default="pending", comment="ìƒíƒœ")
    error_message = Column(String(500), comment="ì—ëŸ¬ ë©”ì‹œì§€")
    retry_count = Column(Integer, default=0, comment="ì¬ì‹œë„ íšŸìˆ˜")
    
    # ì‹œê°„ ì •ë³´
    initiated_at = Column(DateTime(timezone=True), server_default=func.now())
    confirmed_at = Column(DateTime(timezone=True), comment="í™•ì¸ ì‹œê°„")
    
    # ê´€ê³„ ì„¤ì •
    deposit_address = relationship("UserDepositAddress", back_populates="sweep_logs")
```

### Phase 2: HD Wallet ë° Sweep ì„œë¹„ìŠ¤ (2ì¼)

#### 2.1 HD Wallet ê´€ë¦¬ ì„œë¹„ìŠ¤
```python
# app/services/wallet/hd_wallet_service.py
"""HD Wallet ê´€ë¦¬ ì„œë¹„ìŠ¤"""
from typing import Tuple, Optional
from cryptography.fernet import Fernet
from mnemonic import Mnemonic
from tronpy import Tron
from tronpy.keys import PrivateKey
import hashlib
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.hd_wallet import HDWalletMaster, UserDepositAddress
from app.core.config import settings
from app.utils.logger import logger

class HDWalletService:
    """HD Wallet ìƒì„± ë° ê´€ë¦¬"""
    
    def __init__(self, db: AsyncSession):
        self.db = db
        self.tron = Tron(network=settings.TRON_NETWORK)
        self.cipher = Fernet(settings.WALLET_ENCRYPTION_KEY.encode())
    
    async def create_master_wallet(self, partner_id: int) -> HDWalletMaster:
        """íŒŒíŠ¸ë„ˆìš© ë§ˆìŠ¤í„° ì§€ê°‘ ìƒì„±"""
        try:
            # ê¸°ì¡´ ë§ˆìŠ¤í„° ì§€ê°‘ í™•ì¸
            existing = await self.db.query(HDWalletMaster).filter(
                HDWalletMaster.partner_id == partner_id
            ).first()
            
            if existing:
                return existing
            
            # ë‹ˆëª¨ë‹‰ ìƒì„±
            mnemo = Mnemonic("english")
            mnemonic_phrase = mnemo.generate(strength=256)
            
            # ì‹œë“œ ìƒì„±
            seed = mnemo.to_seed(mnemonic_phrase)
            
            # ë§ˆìŠ¤í„° í‚¤ ìƒì„±
            master_key = self._generate_master_key(seed)
            
            # ì•”í˜¸í™” ì €ì¥
            encrypted_seed = self.cipher.encrypt(seed)
            
            # DB ì €ì¥
            hd_wallet = HDWalletMaster(
                partner_id=partner_id,
                encrypted_seed=encrypted_seed.decode(),
                public_key=master_key['public_key']
            )
            
            self.db.add(hd_wallet)
            await self.db.commit()
            await self.db.refresh(hd_wallet)
            
            logger.info(f"Master wallet created for partner {partner_id}")
            return hd_wallet
            
        except Exception as e:
            logger.error(f"Failed to create master wallet: {e}")
            raise
    
    async def generate_deposit_address(
        self, 
        partner_id: int, 
        user_id: int
    ) -> UserDepositAddress:
        """ì‚¬ìš©ììš© ì…ê¸ˆ ì£¼ì†Œ ìƒì„±"""
        try:
            # ê¸°ì¡´ ì£¼ì†Œ í™•ì¸
            existing = await self.db.query(UserDepositAddress).filter(
                UserDepositAddress.user_id == user_id,
                UserDepositAddress.is_active == True
            ).first()
            
            if existing:
                return existing
            
            # ë§ˆìŠ¤í„° ì§€ê°‘ ì¡°íšŒ
            hd_wallet = await self.db.query(HDWalletMaster).filter(
                HDWalletMaster.partner_id == partner_id
            ).first()
            
            if not hd_wallet:
                hd_wallet = await self.create_master_wallet(partner_id)
            
            # íŒŒìƒ ì¸ë±ìŠ¤ ì¦ê°€
            derivation_index = hd_wallet.last_index + 1
            
            # ì£¼ì†Œ íŒŒìƒ
            address, private_key = await self._derive_address(
                hd_wallet,
                derivation_index
            )
            
            # ê°œì¸í‚¤ ì•”í˜¸í™”
            encrypted_private_key = self.cipher.encrypt(private_key.encode())
            
            # ì£¼ì†Œ ìƒì„±
            deposit_address = UserDepositAddress(
                hd_wallet_id=hd_wallet.id,
                user_id=user_id,
                address=address,
                derivation_index=derivation_index,
                encrypted_private_key=encrypted_private_key.decode()
            )
            
            # ë§ˆìŠ¤í„° ì¸ë±ìŠ¤ ì—…ë°ì´íŠ¸
            hd_wallet.last_index = derivation_index
            
            self.db.add(deposit_address)
            await self.db.commit()
            await self.db.refresh(deposit_address)
            
            logger.info(f"Deposit address created for user {user_id}: {address}")
            return deposit_address
            
        except Exception as e:
            logger.error(f"Failed to generate deposit address: {e}")
            raise
    
    def _generate_master_key(self, seed: bytes) -> dict:
        """ë§ˆìŠ¤í„° í‚¤ ìƒì„±"""
        # TRONì€ secp256k1 ì‚¬ìš©
        # ê°„ë‹¨í•œ êµ¬í˜„ (ì‹¤ì œë¡œëŠ” BIP32 ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš© ê¶Œì¥)
        master_private = hashlib.sha256(seed).hexdigest()
        private_key = PrivateKey(bytes.fromhex(master_private))
        
        return {
            'private_key': master_private,
            'public_key': private_key.public_key.hex()
        }
    
    async def _derive_address(
        self, 
        hd_wallet: HDWalletMaster, 
        index: int
    ) -> Tuple[str, str]:
        """ì£¼ì†Œ íŒŒìƒ"""
        # ì‹œë“œ ë³µí˜¸í™”
        encrypted_seed = hd_wallet.encrypted_seed.encode()
        seed = self.cipher.decrypt(encrypted_seed)
        
        # íŒŒìƒ ê²½ë¡œ: m/44'/195'/0'/0/{index}
        derived_seed = hashlib.sha256(
            seed + index.to_bytes(4, 'big')
        ).digest()
        
        # ê°œì¸í‚¤ ìƒì„±
        private_key = PrivateKey(derived_seed)
        
        # ì£¼ì†Œ ìƒì„±
        address = private_key.address
        
        return address, private_key.hex()
    
    async def get_private_key(self, address: str) -> Optional[str]:
        """ì£¼ì†Œì˜ ê°œì¸í‚¤ ì¡°íšŒ (Sweepìš©)"""
        deposit_address = await self.db.query(UserDepositAddress).filter(
            UserDepositAddress.address == address
        ).first()
        
        if not deposit_address:
            return None
        
        # ë³µí˜¸í™”
        encrypted_key = deposit_address.encrypted_private_key.encode()
        private_key = self.cipher.decrypt(encrypted_key).decode()
        
        return private_key
```

#### 2.2 Sweep ì‹¤í–‰ ì„œë¹„ìŠ¤
```python
# app/services/sweep/sweep_executor_service.py
"""Sweep ì‹¤í–‰ ì„œë¹„ìŠ¤"""
from typing import List, Dict, Optional
from decimal import Decimal
from datetime import datetime, timedelta
import asyncio
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from tronpy import Tron
from tronpy.keys import PrivateKey

from app.models.hd_wallet import UserDepositAddress, SweepConfiguration, SweepLog
from app.models.partner_wallet import PartnerWallet
from app.services.wallet.hd_wallet_service import HDWalletService
from app.core.config import settings
from app.utils.logger import logger

class SweepExecutorService:
    """Sweep ì‹¤í–‰ ì—”ì§„"""
    
    def __init__(self, db: AsyncSession):
        self.db = db
        self.tron = Tron(network=settings.TRON_NETWORK)
        self.hd_service = HDWalletService(db)
    
    async def execute_sweep_for_partner(self, partner_id: int) -> Dict:
        """íŒŒíŠ¸ë„ˆì‚¬ì˜ Sweep ì‹¤í–‰"""
        try:
            # Sweep ì„¤ì • ì¡°íšŒ
            config = await self.db.query(SweepConfiguration).filter(
                SweepConfiguration.partner_id == partner_id
            ).first()
            
            if not config or not config.is_enabled:
                return {"status": "disabled", "swept_count": 0}
            
            # Sweep ëŒ€ìƒ ì¡°íšŒ
            addresses = await self._get_sweep_candidates(partner_id, config)
            
            if not addresses:
                return {"status": "no_candidates", "swept_count": 0}
            
            # ëŒ€ìƒ ì§€ê°‘ ì¡°íšŒ
            destination_wallet = await self.db.query(PartnerWallet).filter(
                PartnerWallet.id == config.destination_wallet_id
            ).first()
            
            if not destination_wallet:
                raise ValueError("Destination wallet not found")
            
            # ë°°ì¹˜ ì²˜ë¦¬ ì—¬ë¶€ ê²°ì •
            if config.batch_enabled and len(addresses) > 1:
                result = await self._execute_batch_sweep(
                    addresses,
                    destination_wallet.wallet_address,
                    config
                )
            else:
                result = await self._execute_individual_sweep(
                    addresses,
                    destination_wallet.wallet_address,
                    config
                )
            
            return result
            
        except Exception as e:
            logger.error(f"Failed to execute sweep for partner {partner_id}: {e}")
            raise
    
    async def _get_sweep_candidates(
        self,
        partner_id: int,
        config: SweepConfiguration
    ) -> List[Dict]:
        """Sweep ëŒ€ìƒ ì£¼ì†Œ ì¡°íšŒ"""
        candidates = []
        
        # í™œì„± ì£¼ì†Œ ì¡°íšŒ
        addresses = await self.db.query(UserDepositAddress).join(
            HDWalletMaster
        ).filter(
            HDWalletMaster.partner_id == partner_id,
            UserDepositAddress.is_active == True
        ).all()
        
        for address in addresses:
            # ì”ì•¡ í™•ì¸
            balance = await self._get_usdt_balance(address.address)
            
            if balance <= 0:
                continue
            
            # ìµœì†Œ ê¸ˆì•¡ í™•ì¸
            if balance < config.min_sweep_amount:
                # ì¦‰ì‹œ Sweep ì„ê³„ê°’ í™•ì¸
                if balance < config.immediate_threshold:
                    continue
            
            # ë§ˆì§€ë§‰ Sweep ì‹œê°„ í™•ì¸
            if address.last_sweep_at:
                time_since_sweep = datetime.utcnow() - address.last_sweep_at
                if time_since_sweep < timedelta(minutes=config.sweep_interval_minutes):
                    # ì¦‰ì‹œ Sweep ì„ê³„ê°’ì´ ì•„ë‹ˆë©´ ìŠ¤í‚µ
                    if balance < config.immediate_threshold:
                        continue
            
            candidates.append({
                "address": address,
                "balance": balance,
                "priority": balance >= config.immediate_threshold
            })
        
        # ìš°ì„ ìˆœìœ„ ì •ë ¬ (ê¸ˆì•¡ í° ìˆœì„œ)
        candidates.sort(key=lambda x: x["balance"], reverse=True)
        
        return candidates
    
    async def _execute_individual_sweep(
        self,
        candidates: List[Dict],
        destination: str,
        config: SweepConfiguration
    ) -> Dict:
        """ê°œë³„ Sweep ì‹¤í–‰"""
        swept_count = 0
        total_swept = Decimal("0")
        failed_count = 0
        
        for candidate in candidates:
            try:
                address = candidate["address"]
                balance = candidate["balance"]
                
                # ê°œì¸í‚¤ ì¡°íšŒ
                private_key = await self.hd_service.get_private_key(address.address)
                if not private_key:
                    logger.error(f"Private key not found for {address.address}")
                    continue
                
                # íŠ¸ëœì­ì…˜ ìƒì„± ë° ì „ì†¡
                tx_hash = await self._send_sweep_transaction(
                    from_address=address.address,
                    to_address=destination,
                    amount=balance,
                    private_key=private_key
                )
                
                # ë¡œê·¸ ê¸°ë¡
                sweep_log = SweepLog(
                    deposit_address_id=address.id,
                    sweep_amount=balance,
                    tx_hash=tx_hash,
                    status="pending"
                )
                self.db.add(sweep_log)
                
                # ì£¼ì†Œ ì—…ë°ì´íŠ¸
                address.last_sweep_at = datetime.utcnow()
                
                swept_count += 1
                total_swept += balance
                
                logger.info(f"Swept {balance} USDT from {address.address} (tx: {tx_hash})")
                
            except Exception as e:
                logger.error(f"Failed to sweep from {address.address}: {e}")
                failed_count += 1
        
        await self.db.commit()
        
        return {
            "status": "completed",
            "swept_count": swept_count,
            "failed_count": failed_count,
            "total_amount": float(total_swept)
        }
    
    async def _execute_batch_sweep(
        self,
        candidates: List[Dict],
        destination: str,
        config: SweepConfiguration
    ) -> Dict:
        """ë°°ì¹˜ Sweep ì‹¤í–‰ (ë©€í‹°ì‹œê·¸ íŠ¸ëœì­ì…˜)"""
        # TODO: ë°°ì¹˜ ì²˜ë¦¬ êµ¬í˜„
        # TRONì€ ë©€í‹°ì‹œê·¸ë¥¼ ì§€ì›í•˜ì§€ë§Œ, ë³µì¡ë„ê°€ ë†’ì•„ 
        # ì¼ë‹¨ ê°œë³„ ì²˜ë¦¬ë¡œ ëŒ€ì²´
        return await self._execute_individual_sweep(candidates, destination, config)
    
    async def _get_usdt_balance(self, address: str) -> Decimal:
        """USDT ì”ì•¡ ì¡°íšŒ"""
        try:
            contract = self.tron.get_contract(settings.USDT_CONTRACT_ADDRESS)
            balance = contract.functions.balanceOf(address)
            return Decimal(str(balance / 1e6))
        except Exception as e:
            logger.error(f"Failed to get balance for {address}: {e}")
            return Decimal("0")
    
    async def _send_sweep_transaction(
        self,
        from_address: str,
        to_address: str,
        amount: Decimal,
        private_key: str
    ) -> str:
        """Sweep íŠ¸ëœì­ì…˜ ì „ì†¡"""
        try:
            # USDT ì»¨íŠ¸ë™íŠ¸
            contract = self.tron.get_contract(settings.USDT_CONTRACT_ADDRESS)
            
            # íŠ¸ëœì­ì…˜ ìƒì„±
            txn = contract.functions.transfer(
                to_address,
                int(amount * 1e6)
            ).with_owner(from_address).build()
            
            # ì„œëª…
            private_key_obj = PrivateKey(bytes.fromhex(private_key))
            txn = txn.sign(private_key_obj)
            
            # ì „ì†¡
            result = txn.broadcast()
            
            if result.get("result"):
                return result.get("txid")
            else:
                raise Exception(f"Broadcast failed: {result}")
                
        except Exception as e:
            logger.error(f"Failed to send sweep transaction: {e}")
            raise
```

#### 2.3 Sweep ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤
```python
# app/services/sweep/sweep_monitor_service.py
"""Sweep ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤"""
from typing import Dict, List
from datetime import datetime, timedelta
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func

from app.models.hd_wallet import SweepLog, UserDepositAddress
from app.utils.logger import logger

class SweepMonitorService:
    """Sweep ìƒíƒœ ëª¨ë‹ˆí„°ë§"""
    
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def check_pending_sweeps(self) -> None:
        """ëŒ€ê¸° ì¤‘ì¸ Sweep í™•ì¸"""
        # 10ë¶„ ì´ìƒ pending ìƒíƒœì¸ Sweep ì¡°íšŒ
        timeout = datetime.utcnow() - timedelta(minutes=10)
        
        pending_sweeps = await self.db.query(SweepLog).filter(
            SweepLog.status == "pending",
            SweepLog.initiated_at < timeout
        ).all()
        
        for sweep in pending_sweeps:
            # íŠ¸ëœì­ì…˜ ìƒíƒœ í™•ì¸
            status = await self._check_transaction_status(sweep.tx_hash)
            
            if status == "confirmed":
                sweep.status = "completed"
                sweep.confirmed_at = datetime.utcnow()
            elif status == "failed":
                sweep.status = "failed"
                sweep.error_message = "Transaction failed on chain"
        
        await self.db.commit()
    
    async def get_sweep_statistics(
        self,
        partner_id: int,
        period_days: int = 7
    ) -> Dict:
        """Sweep í†µê³„ ì¡°íšŒ"""
        start_date = datetime.utcnow() - timedelta(days=period_days)
        
        # ì´ Sweep ìˆ˜ ë° ê¸ˆì•¡
        total_stats = await self.db.query(
            func.count(SweepLog.id).label("total_count"),
            func.sum(SweepLog.sweep_amount).label("total_amount"),
            func.avg(SweepLog.gas_used).label("avg_gas")
        ).join(
            UserDepositAddress
        ).join(
            HDWalletMaster
        ).filter(
            HDWalletMaster.partner_id == partner_id,
            SweepLog.initiated_at >= start_date
        ).first()
        
        # ìƒíƒœë³„ í†µê³„
        status_stats = await self.db.query(
            SweepLog.status,
            func.count(SweepLog.id).label("count")
        ).join(
            UserDepositAddress
        ).join(
            HDWalletMaster
        ).filter(
            HDWalletMaster.partner_id == partner_id,
            SweepLog.initiated_at >= start_date
        ).group_by(SweepLog.status).all()
        
        # ì¼ë³„ í†µê³„
        daily_stats = await self.db.query(
            func.date(SweepLog.initiated_at).label("date"),
            func.count(SweepLog.id).label("count"),
            func.sum(SweepLog.sweep_amount).label("amount")
        ).join(
            UserDepositAddress
        ).join(
            HDWalletMaster
        ).filter(
            HDWalletMaster.partner_id == partner_id,
            SweepLog.initiated_at >= start_date
        ).group_by(
            func.date(SweepLog.initiated_at)
        ).all()
        
        return {
            "period_days": period_days,
            "total": {
                "count": total_stats.total_count or 0,
                "amount": float(total_stats.total_amount or 0),
                "avg_gas": float(total_stats.avg_gas or 0)
            },
            "by_status": {
                stat.status: stat.count
                for stat in status_stats
            },
            "daily": [
                {
                    "date": stat.date.isoformat(),
                    "count": stat.count,
                    "amount": float(stat.amount)
                }
                for stat in daily_stats
            ]
        }
    
    async def _check_transaction_status(self, tx_hash: str) -> str:
        """íŠ¸ëœì­ì…˜ ìƒíƒœ í™•ì¸"""
        try:
            from tronpy import Tron
            tron = Tron()
            
            tx_info = tron.get_transaction_info(tx_hash)
            
            if tx_info.get("blockNumber"):
                return "confirmed"
            elif tx_info.get("result") == "FAILED":
                return "failed"
            else:
                return "pending"
                
        except Exception as e:
            logger.error(f"Failed to check transaction status: {e}")
            return "unknown"
```

### Phase 3: Sweep API ë° ìŠ¤ì¼€ì¤„ëŸ¬ (1ì¼)

#### 3.1 Sweep ê´€ë¦¬ API
```python
# app/api/v1/endpoints/partner/sweep.py
"""íŒŒíŠ¸ë„ˆ Sweep ê´€ë¦¬ API"""
from typing import Dict, List
from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.database import get_db
from app.api.deps import get_current_partner
from app.models.partner import Partner
from app.schemas.sweep import (
    SweepConfigResponse,
    SweepConfigUpdate,
    SweepExecuteRequest,
    SweepStatusResponse,
    DepositAddressResponse
)
from app.services.sweep.sweep_executor_service import SweepExecutorService
from app.services.sweep.sweep_monitor_service import SweepMonitorService
from app.services.wallet.hd_wallet_service import HDWalletService

router = APIRouter(tags=["íŒŒíŠ¸ë„ˆ Sweep ê´€ë¦¬"])

@router.get("/config", response_model=SweepConfigResponse)
async def get_sweep_config(
    current_partner: Partner = Depends(get_current_partner),
    db: AsyncSession = Depends(get_db)
):
    """Sweep ì„¤ì • ì¡°íšŒ"""
    from app.models.hd_wallet import SweepConfiguration
    
    config = await db.query(SweepConfiguration).filter(
        SweepConfiguration.partner_id == current_partner.id
    ).first()
    
    if not config:
        # ê¸°ë³¸ ì„¤ì • ìƒì„±
        from app.models.partner_wallet import PartnerWallet
        
        # ì£¼ ì§€ê°‘ ì¡°íšŒ
        main_wallet = await db.query(PartnerWallet).filter(
            PartnerWallet.partner_id == current_partner.id,
            PartnerWallet.is_primary == True
        ).first()
        
        if not main_wallet:
            raise HTTPException(
                status_code=400,
                detail="No primary wallet found. Please connect a wallet first."
            )
        
        config = SweepConfiguration(
            partner_id=current_partner.id,
            destination_wallet_id=main_wallet.id
        )
        db.add(config)
        await db.commit()
        await db.refresh(config)
    
    return SweepConfigResponse.from_orm(config)

@router.put("/config", response_model=SweepConfigResponse)
async def update_sweep_config(
    config_update: SweepConfigUpdate,
    current_partner: Partner = Depends(get_current_partner),
    db: AsyncSession = Depends(get_db)
):
    """Sweep ì„¤ì • ì—…ë°ì´íŠ¸"""
    from app.models.hd_wallet import SweepConfiguration
    
    config = await db.query(SweepConfiguration).filter(
        SweepConfiguration.partner_id == current_partner.id
    ).first()
    
    if not config:
        raise HTTPException(status_code=404, detail="Sweep config not found")
    
    # ì„¤ì • ì—…ë°ì´íŠ¸
    update_data = config_update.dict(exclude_unset=True)
    for field, value in update_data.items():
        setattr(config, field, value)
    
    await db.commit()
    await db.refresh(config)
    
    return SweepConfigResponse.from_orm(config)

@router.post("/execute")
async def execute_sweep(
    background_tasks: BackgroundTasks,
    current_partner: Partner = Depends(get_current_partner),
    db: AsyncSession = Depends(get_db)
):
    """ìˆ˜ë™ Sweep ì‹¤í–‰"""
    executor = SweepExecutorService(db)
    
    # ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì‹¤í–‰
    background_tasks.add_task(
        executor.execute_sweep_for_partner,
        current_partner.id
    )
    
    return {
        "status": "initiated",
        "message": "Sweep execution started in background"
    }

@router.get("/statistics", response_model=Dict)
async def get_sweep_statistics(
    period_days: int = 7,
    current_partner: Partner = Depends(get_current_partner),
    db: AsyncSession = Depends(get_db)
):
    """Sweep í†µê³„ ì¡°íšŒ"""
    monitor = SweepMonitorService(db)
    
    stats = await monitor.get_sweep_statistics(
        partner_id=current_partner.id,
        period_days=period_days
    )
    
    return stats

@router.post("/deposit-address", response_model=DepositAddressResponse)
async def create_deposit_address(
    user_id: int,
    current_partner: Partner = Depends(get_current_partner),
    db: AsyncSession = Depends(get_db)
):
    """ì‚¬ìš©ì ì…ê¸ˆ ì£¼ì†Œ ìƒì„±"""
    hd_service = HDWalletService(db)
    
    address = await hd_service.generate_deposit_address(
        partner_id=current_partner.id,
        user_id=user_id
    )
    
    return DepositAddressResponse(
        user_id=user_id,
        address=address.address,
        created_at=address.created_at
    )
```

#### 3.2 Sweep ìŠ¤ì¼€ì¤„ëŸ¬
```python
# app/services/sweep/sweep_scheduler.py
"""Sweep ìë™ ì‹¤í–‰ ìŠ¤ì¼€ì¤„ëŸ¬"""
import asyncio
from datetime import datetime
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker

from app.models.hd_wallet import SweepConfiguration
from app.services.sweep.sweep_executor_service import SweepExecutorService
from app.core.config import settings
from app.utils.logger import logger

class SweepScheduler:
    """Sweep ìë™ ì‹¤í–‰ ìŠ¤ì¼€ì¤„ëŸ¬"""
    
    def __init__(self):
        self.engine = create_async_engine(settings.DATABASE_URL)
        self.AsyncSessionLocal = sessionmaker(
            self.engine,
            class_=AsyncSession,
            expire_on_commit=False
        )
        self.running = False
    
    async def start(self):
        """ìŠ¤ì¼€ì¤„ëŸ¬ ì‹œì‘"""
        self.running = True
        logger.info("Sweep scheduler started")
        
        while self.running:
            try:
                await self._execute_scheduled_sweeps()
                await asyncio.sleep(60)  # 1ë¶„ë§ˆë‹¤ í™•ì¸
            except Exception as e:
                logger.error(f"Scheduler error: {e}")
                await asyncio.sleep(60)
    
    async def stop(self):
        """ìŠ¤ì¼€ì¤„ëŸ¬ ì¤‘ì§€"""
        self.running = False
        logger.info("Sweep scheduler stopped")
    
    async def _execute_scheduled_sweeps(self):
        """ìŠ¤ì¼€ì¤„ëœ Sweep ì‹¤í–‰"""
        async with self.AsyncSessionLocal() as db:
            # í™œì„±í™”ëœ ëª¨ë“  Sweep ì„¤ì • ì¡°íšŒ
            configs = await db.query(SweepConfiguration).filter(
                SweepConfiguration.is_enabled == True
            ).all()
            
            for config in configs:
                try:
                    # ë§ˆì§€ë§‰ ì‹¤í–‰ ì‹œê°„ í™•ì¸
                    should_run = await self._should_run_sweep(config)
                    
                    if should_run:
                        executor = SweepExecutorService(db)
                        await executor.execute_sweep_for_partner(config.partner_id)
                        
                        logger.info(f"Executed sweep for partner {config.partner_id}")
                        
                except Exception as e:
                    logger.error(f"Failed to execute sweep for partner {config.partner_id}: {e}")
    
    async def _should_run_sweep(self, config: SweepConfiguration) -> bool:
        """Sweep ì‹¤í–‰ ì—¬ë¶€ í™•ì¸"""
        # TODO: ë§ˆì§€ë§‰ ì‹¤í–‰ ì‹œê°„ê³¼ ìŠ¤ì¼€ì¤„ í™•ì¸
        # ê°„ë‹¨íˆ sweep_interval_minutes ê¸°ì¤€ìœ¼ë¡œ íŒë‹¨
        return True
```

### Phase 4: Sweep ëŒ€ì‹œë³´ë“œ UI (1ì¼)

#### 4.1 Sweep ê´€ë¦¬ ëŒ€ì‹œë³´ë“œ
```typescript
// frontend/components/sweep/SweepDashboard.tsx
import React, { useState, useEffect } from 'react';
import { Card, Button, Switch, Input, Select, Alert } from '@/components/ui';
import { RefreshCw, Settings, TrendingUp, AlertTriangle } from 'lucide-react';
import { useSweepConfig } from '@/hooks/useSweepConfig';
import { SweepStatistics } from './SweepStatistics';
import { DepositAddressList } from './DepositAddressList';

export const SweepDashboard: React.FC = () => {
  const { config, statistics, loading, updateConfig, executeSweep } = useSweepConfig();
  const [isExecuting, setIsExecuting] = useState(false);

  const handleManualSweep = async () => {
    setIsExecuting(true);
    try {
      await executeSweep();
      toast.success('Sweep ì‹¤í–‰ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤');
    } catch (error) {
      toast.error('Sweep ì‹¤í–‰ ì‹¤íŒ¨');
    } finally {
      setIsExecuting(false);
    }
  };

  if (loading) return <div>Loading...</div>;

  return (
    <div className="space-y-6">
      {/* Sweep ìƒíƒœ ê°œìš” */}
      <Card className="p-6">
        <div className="flex items-center justify-between mb-4">
          <h2 className="text-2xl font-bold">Sweep ìë™í™”</h2>
          <Button 
            onClick={handleManualSweep}
            disabled={isExecuting || !config?.is_enabled}
          >
            <RefreshCw className={`w-4 h-4 mr-2 ${isExecuting ? 'animate-spin' : ''}`} />
            ìˆ˜ë™ ì‹¤í–‰
          </Button>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          <div className="text-center">
            <p className="text-gray-600">ì˜¤ëŠ˜ Sweep</p>
            <p className="text-2xl font-bold">{statistics?.today?.count || 0}ê±´</p>
            <p className="text-sm text-gray-500">
              {statistics?.today?.amount || 0} USDT
            </p>
          </div>
          
          <div className="text-center">
            <p className="text-gray-600">ëŒ€ê¸° ì¤‘</p>
            <p className="text-2xl font-bold text-yellow-600">
              {statistics?.pending || 0}ê±´
            </p>
          </div>
          
          <div className="text-center">
            <p className="text-gray-600">í‰ê·  ê°€ìŠ¤ë¹„</p>
            <p className="text-2xl font-bold">
              {statistics?.avg_gas || 0} TRX
            </p>
          </div>
        </div>
      </Card>

      {/* Sweep ì„¤ì • */}
      <Card className="p-6">
        <h3 className="text-lg font-semibold mb-4">
          <Settings className="w-5 h-5 inline mr-2" />
          Sweep ì„¤ì •
        </h3>

        <div className="space-y-4">
          <div className="flex items-center justify-between">
            <span>Sweep í™œì„±í™”</span>
            <Switch
              checked={config?.is_enabled || false}
              onChange={(checked) => updateConfig({ is_enabled: checked })}
            />
          </div>

          <div>
            <label className="block text-sm font-medium mb-2">
              ëŒ€ìƒ ì§€ê°‘
            </label>
            <Select
              value={config?.destination_wallet_id || ''}
              onChange={(e) => updateConfig({ 
                destination_wallet_id: parseInt(e.target.value) 
              })}
              disabled={!config?.is_enabled}
            >
              <option value="">ì„ íƒí•˜ì„¸ìš”</option>
              {/* ì§€ê°‘ ëª©ë¡ */}
            </Select>
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium mb-2">
                ìµœì†Œ Sweep ê¸ˆì•¡ (USDT)
              </label>
              <Input
                type="number"
                value={config?.min_sweep_amount || 10}
                onChange={(e) => updateConfig({ 
                  min_sweep_amount: parseFloat(e.target.value) 
                })}
                disabled={!config?.is_enabled}
              />
            </div>
            
            <div>
              <label className="block text-sm font-medium mb-2">
                Sweep ê°„ê²© (ë¶„)
              </label>
              <Input
                type="number"
                value={config?.sweep_interval_minutes || 60}
                onChange={(e) => updateConfig({ 
                  sweep_interval_minutes: parseInt(e.target.value) 
                })}
                disabled={!config?.is_enabled}
              />
            </div>
          </div>

          <div>
            <label className="block text-sm font-medium mb-2">
              ì¦‰ì‹œ Sweep ì„ê³„ê°’ (USDT)
            </label>
            <Input
              type="number"
              value={config?.immediate_threshold || 1000}
              onChange={(e) => updateConfig({ 
                immediate_threshold: parseFloat(e.target.value) 
              })}
              disabled={!config?.is_enabled}
            />
            <p className="text-sm text-gray-500 mt-1">
              ì´ ê¸ˆì•¡ ì´ìƒ ì…ê¸ˆ ì‹œ ì¦‰ì‹œ Sweep ì‹¤í–‰
            </p>
          </div>
        </div>
      </Card>

      {/* Sweep í†µê³„ */}
      <SweepStatistics statistics={statistics} />

      {/* ì…ê¸ˆ ì£¼ì†Œ ëª©ë¡ */}
      <DepositAddressList />
    </div>
  );
};
```

## ğŸ”§ ë°ì´í„°ë² ì´ìŠ¤ ë§ˆì´ê·¸ë ˆì´ì…˜

```sql
-- HD Wallet ë§ˆìŠ¤í„° í…Œì´ë¸”
CREATE TABLE hd_wallet_masters (
    id SERIAL PRIMARY KEY,
    partner_id INTEGER NOT NULL UNIQUE REFERENCES partners(id),
    encrypted_seed VARCHAR(500) NOT NULL,
    public_key VARCHAR(130) NOT NULL,
    derivation_path VARCHAR(100) DEFAULT 'm/44''/195''/0''/0',
    last_index INTEGER DEFAULT 0,
    encryption_method VARCHAR(50) DEFAULT 'AES-256-GCM',
    key_version INTEGER DEFAULT 1,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ì‚¬ìš©ì ì…ê¸ˆ ì£¼ì†Œ í…Œì´ë¸”
CREATE TABLE user_deposit_addresses (
    id SERIAL PRIMARY KEY,
    hd_wallet_id INTEGER NOT NULL REFERENCES hd_wallet_masters(id),
    user_id INTEGER NOT NULL REFERENCES users(id),
    address VARCHAR(42) NOT NULL UNIQUE,
    derivation_index INTEGER NOT NULL,
    encrypted_private_key VARCHAR(500) NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    total_received DECIMAL(18,6) DEFAULT 0,
    last_sweep_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    INDEX idx_deposit_address_user (user_id),
    INDEX idx_deposit_address_active (is_active),
    INDEX idx_deposit_address (address)
);

-- Sweep ì„¤ì • í…Œì´ë¸”
CREATE TABLE sweep_configurations (
    id SERIAL PRIMARY KEY,
    partner_id INTEGER NOT NULL UNIQUE REFERENCES partners(id),
    destination_wallet_id INTEGER NOT NULL REFERENCES partner_wallets(id),
    is_enabled BOOLEAN DEFAULT TRUE,
    min_sweep_amount DECIMAL(18,6) DEFAULT 10,
    sweep_interval_minutes INTEGER DEFAULT 60,
    immediate_threshold DECIMAL(18,6) DEFAULT 1000,
    max_gas_price_sun NUMERIC(20,0) DEFAULT 1000,
    gas_optimization_enabled BOOLEAN DEFAULT TRUE,
    batch_enabled BOOLEAN DEFAULT TRUE,
    max_batch_size INTEGER DEFAULT 20,
    notification_enabled BOOLEAN DEFAULT TRUE,
    notification_channels JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Sweep ë¡œê·¸ í…Œì´ë¸”
CREATE TABLE sweep_logs (
    id SERIAL PRIMARY KEY,
    deposit_address_id INTEGER NOT NULL REFERENCES user_deposit_addresses(id),
    sweep_amount DECIMAL(18,6) NOT NULL,
    gas_used NUMERIC(20,0),
    gas_price NUMERIC(20,0),
    tx_hash VARCHAR(66),
    status VARCHAR(20) DEFAULT 'pending',
    error_message VARCHAR(500),
    retry_count INTEGER DEFAULT 0,
    initiated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    confirmed_at TIMESTAMP WITH TIME ZONE,
    
    INDEX idx_sweep_logs_address (deposit_address_id),
    INDEX idx_sweep_logs_status (status),
    INDEX idx_sweep_logs_tx_hash (tx_hash)
);
```

## âœ… ê²€ì¦ í¬ì¸íŠ¸

- [ ] HD Walletì´ ì•ˆì „í•˜ê²Œ ìƒì„±ë˜ê³  ì•”í˜¸í™”ë˜ëŠ”ê°€?
- [ ] ì‚¬ìš©ìë³„ ì…ê¸ˆ ì£¼ì†Œê°€ ì •í™•íˆ íŒŒìƒë˜ëŠ”ê°€?
- [ ] ì…ê¸ˆì´ ì‹¤ì‹œê°„ìœ¼ë¡œ ê°ì§€ë˜ëŠ”ê°€?
- [ ] ìµœì†Œ ê¸ˆì•¡ ë° ìŠ¤ì¼€ì¤„ì— ë”°ë¼ Sweepê°€ ì‹¤í–‰ë˜ëŠ”ê°€?
- [ ] ì¦‰ì‹œ Sweep ì„ê³„ê°’ì´ ì‘ë™í•˜ëŠ”ê°€?
- [ ] ê°€ìŠ¤ë¹„ ìµœì í™”ê°€ ì •ìƒ ì‘ë™í•˜ëŠ”ê°€?
- [ ] Sweep ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„ê°€ ë˜ëŠ”ê°€?
- [ ] í†µê³„ ë° ëª¨ë‹ˆí„°ë§ì´ ì •í™•í•œê°€?

## ğŸ‰ ê¸°ëŒ€ íš¨ê³¼

1. **ë³´ì•ˆ ê°•í™”**: ì¤‘ì•™ ì§€ê°‘ìœ¼ë¡œ ìì‚° ì§‘ì¤‘ ê´€ë¦¬
2. **ìš´ì˜ íš¨ìœ¨**: ìë™í™”ë¥¼ í†µí•œ ìˆ˜ë™ ì‘ì—… ìµœì†Œí™”
3. **ë¹„ìš© ìµœì í™”**: ë°°ì¹˜ ì²˜ë¦¬ ë° ê°€ìŠ¤ë¹„ ìµœì í™”
4. **íˆ¬ëª…ì„±**: ëª¨ë“  Sweep ì´ë ¥ ì¶”ì  ê°€ëŠ¥
5. **ìœ ì—°ì„±**: íŒŒíŠ¸ë„ˆì‚¬ë³„ ë§ì¶¤ ì •ì±… ì„¤ì •

ì´ ì‹œìŠ¤í…œì„ í†µí•´ ì‚¬ìš©ì ì…ê¸ˆì„ ì•ˆì „í•˜ê³  íš¨ìœ¨ì ìœ¼ë¡œ ì¤‘ì•™ ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.